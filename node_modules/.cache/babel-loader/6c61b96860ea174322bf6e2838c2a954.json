{"ast":null,"code":"'use strict';var high=require('highlight.js/lib/highlight.js');var fault=require('fault');// The lowlight interface, which has to be compatible with highlight.js, as\n// this object is passed to highlight.js syntaxes.\nfunction High(){}High.prototype=high;// Expose.\nvar low=new High();// Ha!\nmodule.exports=low;low.highlight=highlight;low.highlightAuto=autoHighlight;low.registerLanguage=registerLanguage;low.listLanguages=listLanguages;low.registerAlias=registerAlias;low.getLanguage=getLanguage;var inherit=high.inherit;var own={}.hasOwnProperty;var concat=[].concat;var defaultPrefix='hljs-';var keyInsensitive='case_insensitive';var keyCachedVariants='cached_variants';var space=' ';var verticalBar='|';// Maps of syntaxes.\nvar languageNames=[];var languages={};var aliases={};// Highlighting with language detection.\n// Accepts a string with the code to highlight.\n// Returns an object with the following properties:\n//\n// *   `language` — Detected language\n// *   `relevance` — Integer\n// *   `value` — HAST tree with highlighting markup\n// *   `secondBest` — Object with the same structure for second-best\n//     heuristically detected language, may be absent.\nfunction autoHighlight(value,options){var settings=options||{};var subset=settings.subset||languageNames;var prefix=settings.prefix;var length=subset.length;var index=-1;var result;var secondBest;var current;var name;if(prefix===null||prefix===undefined){prefix=defaultPrefix;}if(typeof value!=='string'){throw fault('Expected `string` for value, got `%s`',value);}secondBest=normalize({});result=normalize({});while(++index<length){name=subset[index];if(!getLanguage(name)){continue;}current=normalize(coreHighlight(name,value,false,prefix));current.language=name;if(current.relevance>secondBest.relevance){secondBest=current;}if(current.relevance>result.relevance){secondBest=result;result=current;}}if(secondBest.language){result.secondBest=secondBest;}return result;}// Highlighting `value` in the language `language`.\nfunction highlight(language,value,options){var settings=options||{};var prefix=settings.prefix;if(prefix===null||prefix===undefined){prefix=defaultPrefix;}return normalize(coreHighlight(language,value,true,prefix));}// Register a language.\nfunction registerLanguage(name,syntax){var lang=syntax(low);languages[name]=lang;languageNames.push(name);if(lang.aliases){registerAlias(name,lang.aliases);}}// Get a list of all registered languages.\nfunction listLanguages(){return languageNames.concat();}// Register more aliases for an already registered language.\nfunction registerAlias(name,alias){var map=name;var key;var list;var length;var index;if(alias){map={};map[name]=alias;}for(key in map){list=map[key];list=typeof list==='string'?[list]:list;length=list.length;index=-1;while(++index<length){aliases[list[index]]=key;}}}// Core highlighting function.\n// Accepts a language name, or an alias, and a string with the code to\n// highlight.\n// eslint-disable-next-line max-params\nfunction coreHighlight(name,value,ignore,prefix,continuation){var continuations={};var stack=[];var modeBuffer='';var relevance=0;var language;var top;var current;var currentChildren;var offset;var count;var match;var children;if(typeof name!=='string'){throw fault('Expected `string` for name, got `%s`',name);}if(typeof value!=='string'){throw fault('Expected `string` for value, got `%s`',value);}language=getLanguage(name);top=continuation||language;children=[];current=top;currentChildren=children;if(!language){throw fault('Unknown language: `%s` is not registered',name);}compileLanguage(language);try{top.terminators.lastIndex=0;offset=0;match=top.terminators.exec(value);while(match){count=processLexeme(value.substring(offset,match.index),match[0]);offset=match.index+count;top.terminators.lastIndex=offset;match=top.terminators.exec(value);}processLexeme(value.substr(offset));current=top;while(current.parent){if(current.className){pop();}current=current.parent;}return{relevance:relevance,value:currentChildren,language:name,top:top};}catch(error){/* istanbul ignore if - Catch-all  */if(error.message.indexOf('Illegal')===-1){throw error;}return{relevance:0,value:addText(value,[])};}// Process a lexeme.  Returns next position.\nfunction processLexeme(buffer,lexeme){var newMode;var endMode;var origin;modeBuffer+=buffer;if(lexeme===undefined){addSiblings(processBuffer(),currentChildren);return 0;}newMode=subMode(lexeme,top);if(newMode){addSiblings(processBuffer(),currentChildren);startNewMode(newMode,lexeme);return newMode.returnBegin?0:lexeme.length;}endMode=endOfMode(top,lexeme);if(endMode){origin=top;if(!(origin.returnEnd||origin.excludeEnd)){modeBuffer+=lexeme;}addSiblings(processBuffer(),currentChildren);// Close open modes.\ndo{if(top.className){pop();}relevance+=top.relevance;top=top.parent;}while(top!==endMode.parent);if(origin.excludeEnd){addText(lexeme,currentChildren);}modeBuffer='';if(endMode.starts){startNewMode(endMode.starts,'');}return origin.returnEnd?0:lexeme.length;}if(isIllegal(lexeme,top)){throw fault('Illegal lexeme \"%s\" for mode \"%s\"',lexeme,top.className||'<unnamed>');}// Parser should not reach this point as all types of lexemes should be\n// caught earlier, but if it does due to some bug make sure it advances\n// at least one character forward to prevent infinite looping.\nmodeBuffer+=lexeme;return lexeme.length||/* istanbul ignore next */1;}// Start a new mode with a `lexeme` to process.\nfunction startNewMode(mode,lexeme){var node;if(mode.className){node=build(mode.className,[]);}if(mode.returnBegin){modeBuffer='';}else if(mode.excludeBegin){addText(lexeme,currentChildren);modeBuffer='';}else{modeBuffer=lexeme;}// Enter a new mode.\nif(node){currentChildren.push(node);stack.push(currentChildren);currentChildren=node.children;}top=Object.create(mode,{parent:{value:top}});}// Process the buffer.\nfunction processBuffer(){var result=top.subLanguage?processSubLanguage():processKeywords();modeBuffer='';return result;}// Process a sublanguage (returns a list of nodes).\nfunction processSubLanguage(){var explicit=typeof top.subLanguage==='string';var subvalue;/* istanbul ignore if - support non-loaded sublanguages */if(explicit&&!languages[top.subLanguage]){return addText(modeBuffer,[]);}if(explicit){subvalue=coreHighlight(top.subLanguage,modeBuffer,true,prefix,continuations[top.subLanguage]);}else{subvalue=autoHighlight(modeBuffer,{subset:top.subLanguage.length===0?undefined:top.subLanguage,prefix:prefix});}// If we couldn’t highlight, for example because the requests subset isn’t\n// loaded, return a text node.\nif(!subvalue.language){return[buildText(modeBuffer)];}// Counting embedded language score towards the host language may be\n// disabled with zeroing the containing mode relevance.\n// Usecase in point is Markdown that allows XML everywhere and makes every\n// XML snippet to have a much larger Markdown score.\nif(top.relevance>0){relevance+=subvalue.relevance;}if(explicit){continuations[top.subLanguage]=subvalue.top;}return[build(subvalue.language,subvalue.value,true)];}// Process keywords. Returns nodes.\nfunction processKeywords(){var nodes=[];var lastIndex;var keyword;var node;var submatch;if(!top.keywords){return addText(modeBuffer,nodes);}lastIndex=0;top.lexemesRe.lastIndex=0;keyword=top.lexemesRe.exec(modeBuffer);while(keyword){addText(modeBuffer.substring(lastIndex,keyword.index),nodes);submatch=keywordMatch(top,keyword);if(submatch){relevance+=submatch[1];node=build(submatch[0],[]);nodes.push(node);addText(keyword[0],node.children);}else{addText(keyword[0],nodes);}lastIndex=top.lexemesRe.lastIndex;keyword=top.lexemesRe.exec(modeBuffer);}addText(modeBuffer.substr(lastIndex),nodes);return nodes;}// Add siblings.\nfunction addSiblings(siblings,nodes){var length=siblings.length;var index=-1;var sibling;while(++index<length){sibling=siblings[index];if(sibling.type==='text'){addText(sibling.value,nodes);}else{nodes.push(sibling);}}}// Add a text.\nfunction addText(value,nodes){var tail;if(value){tail=nodes[nodes.length-1];if(tail&&tail.type==='text'){tail.value+=value;}else{nodes.push(buildText(value));}}return nodes;}// Build a text.\nfunction buildText(value){return{type:'text',value:value};}// Build a span.\nfunction build(name,contents,noPrefix){return{type:'element',tagName:'span',properties:{className:[(noPrefix?'':prefix)+name]},children:contents};}// Check if the first word in `keywords` is a keyword.\nfunction keywordMatch(mode,keywords){var keyword=keywords[0];if(language[keyInsensitive]){keyword=keyword.toLowerCase();}return own.call(mode.keywords,keyword)&&mode.keywords[keyword];}// Check if `lexeme` is illegal according to `mode`.\nfunction isIllegal(lexeme,mode){return!ignore&&test(mode.illegalRe,lexeme);}// Check if `lexeme` ends `mode`.\nfunction endOfMode(mode,lexeme){if(test(mode.endRe,lexeme)){while(mode.endsParent&&mode.parent){mode=mode.parent;}return mode;}if(mode.endsWithParent){return endOfMode(mode.parent,lexeme);}}// Check a sub-mode.\nfunction subMode(lexeme,mode){var values=mode.contains;var length=values.length;var index=-1;while(++index<length){if(test(values[index].beginRe,lexeme)){return values[index];}}}// Exit the current context.\nfunction pop(){/* istanbul ignore next - removed in hljs 9.3 */currentChildren=stack.pop()||children;}}function expandMode(mode){var length;var index;var variants;var result;if(mode.variants&&!mode[keyCachedVariants]){variants=mode.variants;length=variants.length;index=-1;result=[];while(++index<length){result[index]=inherit(mode,{variants:null},variants[index]);}mode[keyCachedVariants]=result;}return mode[keyCachedVariants]||(mode.endsWithParent?[inherit(mode)]:[mode]);}// Compile a language.\nfunction compileLanguage(language){compileMode(language);// Compile a language mode, optionally with a parent.\n// eslint-disable-next-line complexity\nfunction compileMode(mode,parent){var compiledKeywords={};var terminators;if(mode.compiled){return;}mode.compiled=true;mode.keywords=mode.keywords||mode.beginKeywords;if(mode.keywords){if(typeof mode.keywords==='string'){flatten('keyword',mode.keywords);}else{Object.keys(mode.keywords).forEach(function(className){flatten(className,mode.keywords[className]);});}mode.keywords=compiledKeywords;}mode.lexemesRe=langRe(mode.lexemes||/\\w+/,true);if(parent){if(mode.beginKeywords){mode.begin='\\\\b('+mode.beginKeywords.split(space).join(verticalBar)+')\\\\b';}if(!mode.begin){mode.begin=/\\B|\\b/;}mode.beginRe=langRe(mode.begin);if(!mode.end&&!mode.endsWithParent){mode.end=/\\B|\\b/;}if(mode.end){mode.endRe=langRe(mode.end);}mode.terminatorEnd=source(mode.end)||'';if(mode.endsWithParent&&parent.terminatorEnd){mode.terminatorEnd+=(mode.end?verticalBar:'')+parent.terminatorEnd;}}if(mode.illegal){mode.illegalRe=langRe(mode.illegal);}if(mode.relevance===undefined){mode.relevance=1;}if(!mode.contains){mode.contains=[];}mode.contains=concat.apply([],mode.contains.map(function(c){return expandMode(c==='self'?mode:c);}));mode.contains.forEach(function(c){compileMode(c,mode);});if(mode.starts){compileMode(mode.starts,parent);}terminators=mode.contains.map(map).concat([mode.terminatorEnd,mode.illegal]).map(source).filter(Boolean);mode.terminators=terminators.length===0?{exec:execNoop}:langRe(terminators.join(verticalBar),true);function map(c){return c.beginKeywords?'\\\\.?('+c.begin+')\\\\.?':c.begin;}// Flatten a classname.\nfunction flatten(className,value){var pairs;var pair;var index;var length;if(language[keyInsensitive]){value=value.toLowerCase();}pairs=value.split(space);length=pairs.length;index=-1;while(++index<length){pair=pairs[index].split(verticalBar);compiledKeywords[pair[0]]=[className,pair[1]?Number(pair[1]):1];}}}// Create a regex for `value`.\nfunction langRe(value,global){return new RegExp(source(value),'m'+(language[keyInsensitive]?'i':'')+(global?'g':''));}// Get the source of an expression or string.\nfunction source(re){return re&&re.source||re;}}// Normalize a syntax result.\nfunction normalize(result){return{relevance:result.relevance||0,language:result.language||null,value:result.value||[]};}// Check if `expression` matches `lexeme`.\nfunction test(expression,lexeme){var match=expression&&expression.exec(lexeme);return match&&match.index===0;}// No-op exec.\nfunction execNoop(){return null;}// Get a language by `name`.\nfunction getLanguage(name){name=name.toLowerCase();return languages[name]||languages[aliases[name]];}","map":{"version":3,"names":["high","require","fault","High","prototype","low","module","exports","highlight","highlightAuto","autoHighlight","registerLanguage","listLanguages","registerAlias","getLanguage","inherit","own","hasOwnProperty","concat","defaultPrefix","keyInsensitive","keyCachedVariants","space","verticalBar","languageNames","languages","aliases","value","options","settings","subset","prefix","length","index","result","secondBest","current","name","undefined","normalize","coreHighlight","language","relevance","syntax","lang","push","alias","map","key","list","ignore","continuation","continuations","stack","modeBuffer","top","currentChildren","offset","count","match","children","compileLanguage","terminators","lastIndex","exec","processLexeme","substring","substr","parent","className","pop","error","message","indexOf","addText","buffer","lexeme","newMode","endMode","origin","addSiblings","processBuffer","subMode","startNewMode","returnBegin","endOfMode","returnEnd","excludeEnd","starts","isIllegal","mode","node","build","excludeBegin","Object","create","subLanguage","processSubLanguage","processKeywords","explicit","subvalue","buildText","nodes","keyword","submatch","keywords","lexemesRe","keywordMatch","siblings","sibling","type","tail","contents","noPrefix","tagName","properties","toLowerCase","call","test","illegalRe","endRe","endsParent","endsWithParent","values","contains","beginRe","expandMode","variants","compileMode","compiledKeywords","compiled","beginKeywords","flatten","keys","forEach","langRe","lexemes","begin","split","join","end","terminatorEnd","source","illegal","apply","c","filter","Boolean","execNoop","pairs","pair","Number","global","RegExp","re","expression"],"sources":["/home/andrea/progetti/andrea-portfolio/frontend/node_modules/lowlight/lib/core.js"],"sourcesContent":["'use strict'\n\nvar high = require('highlight.js/lib/highlight.js')\nvar fault = require('fault')\n\n// The lowlight interface, which has to be compatible with highlight.js, as\n// this object is passed to highlight.js syntaxes.\n\nfunction High() {}\n\nHigh.prototype = high\n\n// Expose.\nvar low = new High() // Ha!\n\nmodule.exports = low\n\nlow.highlight = highlight\nlow.highlightAuto = autoHighlight\nlow.registerLanguage = registerLanguage\nlow.listLanguages = listLanguages\nlow.registerAlias = registerAlias\nlow.getLanguage = getLanguage\n\nvar inherit = high.inherit\nvar own = {}.hasOwnProperty\nvar concat = [].concat\n\nvar defaultPrefix = 'hljs-'\nvar keyInsensitive = 'case_insensitive'\nvar keyCachedVariants = 'cached_variants'\nvar space = ' '\nvar verticalBar = '|'\n\n// Maps of syntaxes.\nvar languageNames = []\nvar languages = {}\nvar aliases = {}\n\n// Highlighting with language detection.\n// Accepts a string with the code to highlight.\n// Returns an object with the following properties:\n//\n// *   `language` — Detected language\n// *   `relevance` — Integer\n// *   `value` — HAST tree with highlighting markup\n// *   `secondBest` — Object with the same structure for second-best\n//     heuristically detected language, may be absent.\nfunction autoHighlight(value, options) {\n  var settings = options || {}\n  var subset = settings.subset || languageNames\n  var prefix = settings.prefix\n  var length = subset.length\n  var index = -1\n  var result\n  var secondBest\n  var current\n  var name\n\n  if (prefix === null || prefix === undefined) {\n    prefix = defaultPrefix\n  }\n\n  if (typeof value !== 'string') {\n    throw fault('Expected `string` for value, got `%s`', value)\n  }\n\n  secondBest = normalize({})\n  result = normalize({})\n\n  while (++index < length) {\n    name = subset[index]\n\n    if (!getLanguage(name)) {\n      continue\n    }\n\n    current = normalize(coreHighlight(name, value, false, prefix))\n\n    current.language = name\n\n    if (current.relevance > secondBest.relevance) {\n      secondBest = current\n    }\n\n    if (current.relevance > result.relevance) {\n      secondBest = result\n      result = current\n    }\n  }\n\n  if (secondBest.language) {\n    result.secondBest = secondBest\n  }\n\n  return result\n}\n\n// Highlighting `value` in the language `language`.\nfunction highlight(language, value, options) {\n  var settings = options || {}\n  var prefix = settings.prefix\n\n  if (prefix === null || prefix === undefined) {\n    prefix = defaultPrefix\n  }\n\n  return normalize(coreHighlight(language, value, true, prefix))\n}\n\n// Register a language.\nfunction registerLanguage(name, syntax) {\n  var lang = syntax(low)\n\n  languages[name] = lang\n\n  languageNames.push(name)\n\n  if (lang.aliases) {\n    registerAlias(name, lang.aliases)\n  }\n}\n\n// Get a list of all registered languages.\nfunction listLanguages() {\n  return languageNames.concat()\n}\n\n// Register more aliases for an already registered language.\nfunction registerAlias(name, alias) {\n  var map = name\n  var key\n  var list\n  var length\n  var index\n\n  if (alias) {\n    map = {}\n    map[name] = alias\n  }\n\n  for (key in map) {\n    list = map[key]\n    list = typeof list === 'string' ? [list] : list\n    length = list.length\n    index = -1\n\n    while (++index < length) {\n      aliases[list[index]] = key\n    }\n  }\n}\n\n// Core highlighting function.\n// Accepts a language name, or an alias, and a string with the code to\n// highlight.\n// eslint-disable-next-line max-params\nfunction coreHighlight(name, value, ignore, prefix, continuation) {\n  var continuations = {}\n  var stack = []\n  var modeBuffer = ''\n  var relevance = 0\n  var language\n  var top\n  var current\n  var currentChildren\n  var offset\n  var count\n  var match\n  var children\n\n  if (typeof name !== 'string') {\n    throw fault('Expected `string` for name, got `%s`', name)\n  }\n\n  if (typeof value !== 'string') {\n    throw fault('Expected `string` for value, got `%s`', value)\n  }\n\n  language = getLanguage(name)\n  top = continuation || language\n  children = []\n\n  current = top\n  currentChildren = children\n\n  if (!language) {\n    throw fault('Unknown language: `%s` is not registered', name)\n  }\n\n  compileLanguage(language)\n\n  try {\n    top.terminators.lastIndex = 0\n    offset = 0\n    match = top.terminators.exec(value)\n\n    while (match) {\n      count = processLexeme(value.substring(offset, match.index), match[0])\n      offset = match.index + count\n      top.terminators.lastIndex = offset\n      match = top.terminators.exec(value)\n    }\n\n    processLexeme(value.substr(offset))\n    current = top\n\n    while (current.parent) {\n      if (current.className) {\n        pop()\n      }\n\n      current = current.parent\n    }\n\n    return {\n      relevance: relevance,\n      value: currentChildren,\n      language: name,\n      top: top\n    }\n  } catch (error) {\n    /* istanbul ignore if - Catch-all  */\n    if (error.message.indexOf('Illegal') === -1) {\n      throw error\n    }\n\n    return {relevance: 0, value: addText(value, [])}\n  }\n\n  // Process a lexeme.  Returns next position.\n  function processLexeme(buffer, lexeme) {\n    var newMode\n    var endMode\n    var origin\n\n    modeBuffer += buffer\n\n    if (lexeme === undefined) {\n      addSiblings(processBuffer(), currentChildren)\n\n      return 0\n    }\n\n    newMode = subMode(lexeme, top)\n\n    if (newMode) {\n      addSiblings(processBuffer(), currentChildren)\n\n      startNewMode(newMode, lexeme)\n\n      return newMode.returnBegin ? 0 : lexeme.length\n    }\n\n    endMode = endOfMode(top, lexeme)\n\n    if (endMode) {\n      origin = top\n\n      if (!(origin.returnEnd || origin.excludeEnd)) {\n        modeBuffer += lexeme\n      }\n\n      addSiblings(processBuffer(), currentChildren)\n\n      // Close open modes.\n      do {\n        if (top.className) {\n          pop()\n        }\n\n        relevance += top.relevance\n        top = top.parent\n      } while (top !== endMode.parent)\n\n      if (origin.excludeEnd) {\n        addText(lexeme, currentChildren)\n      }\n\n      modeBuffer = ''\n\n      if (endMode.starts) {\n        startNewMode(endMode.starts, '')\n      }\n\n      return origin.returnEnd ? 0 : lexeme.length\n    }\n\n    if (isIllegal(lexeme, top)) {\n      throw fault(\n        'Illegal lexeme \"%s\" for mode \"%s\"',\n        lexeme,\n        top.className || '<unnamed>'\n      )\n    }\n\n    // Parser should not reach this point as all types of lexemes should be\n    // caught earlier, but if it does due to some bug make sure it advances\n    // at least one character forward to prevent infinite looping.\n    modeBuffer += lexeme\n\n    return lexeme.length || /* istanbul ignore next */ 1\n  }\n\n  // Start a new mode with a `lexeme` to process.\n  function startNewMode(mode, lexeme) {\n    var node\n\n    if (mode.className) {\n      node = build(mode.className, [])\n    }\n\n    if (mode.returnBegin) {\n      modeBuffer = ''\n    } else if (mode.excludeBegin) {\n      addText(lexeme, currentChildren)\n\n      modeBuffer = ''\n    } else {\n      modeBuffer = lexeme\n    }\n\n    // Enter a new mode.\n    if (node) {\n      currentChildren.push(node)\n      stack.push(currentChildren)\n      currentChildren = node.children\n    }\n\n    top = Object.create(mode, {parent: {value: top}})\n  }\n\n  // Process the buffer.\n  function processBuffer() {\n    var result = top.subLanguage ? processSubLanguage() : processKeywords()\n    modeBuffer = ''\n    return result\n  }\n\n  // Process a sublanguage (returns a list of nodes).\n  function processSubLanguage() {\n    var explicit = typeof top.subLanguage === 'string'\n    var subvalue\n\n    /* istanbul ignore if - support non-loaded sublanguages */\n    if (explicit && !languages[top.subLanguage]) {\n      return addText(modeBuffer, [])\n    }\n\n    if (explicit) {\n      subvalue = coreHighlight(\n        top.subLanguage,\n        modeBuffer,\n        true,\n        prefix,\n        continuations[top.subLanguage]\n      )\n    } else {\n      subvalue = autoHighlight(modeBuffer, {\n        subset: top.subLanguage.length === 0 ? undefined : top.subLanguage,\n        prefix: prefix\n      })\n    }\n\n    // If we couldn’t highlight, for example because the requests subset isn’t\n    // loaded, return a text node.\n    if (!subvalue.language) {\n      return [buildText(modeBuffer)]\n    }\n\n    // Counting embedded language score towards the host language may be\n    // disabled with zeroing the containing mode relevance.\n    // Usecase in point is Markdown that allows XML everywhere and makes every\n    // XML snippet to have a much larger Markdown score.\n    if (top.relevance > 0) {\n      relevance += subvalue.relevance\n    }\n\n    if (explicit) {\n      continuations[top.subLanguage] = subvalue.top\n    }\n\n    return [build(subvalue.language, subvalue.value, true)]\n  }\n\n  // Process keywords. Returns nodes.\n  function processKeywords() {\n    var nodes = []\n    var lastIndex\n    var keyword\n    var node\n    var submatch\n\n    if (!top.keywords) {\n      return addText(modeBuffer, nodes)\n    }\n\n    lastIndex = 0\n\n    top.lexemesRe.lastIndex = 0\n\n    keyword = top.lexemesRe.exec(modeBuffer)\n\n    while (keyword) {\n      addText(modeBuffer.substring(lastIndex, keyword.index), nodes)\n\n      submatch = keywordMatch(top, keyword)\n\n      if (submatch) {\n        relevance += submatch[1]\n\n        node = build(submatch[0], [])\n\n        nodes.push(node)\n\n        addText(keyword[0], node.children)\n      } else {\n        addText(keyword[0], nodes)\n      }\n\n      lastIndex = top.lexemesRe.lastIndex\n      keyword = top.lexemesRe.exec(modeBuffer)\n    }\n\n    addText(modeBuffer.substr(lastIndex), nodes)\n\n    return nodes\n  }\n\n  // Add siblings.\n  function addSiblings(siblings, nodes) {\n    var length = siblings.length\n    var index = -1\n    var sibling\n\n    while (++index < length) {\n      sibling = siblings[index]\n\n      if (sibling.type === 'text') {\n        addText(sibling.value, nodes)\n      } else {\n        nodes.push(sibling)\n      }\n    }\n  }\n\n  // Add a text.\n  function addText(value, nodes) {\n    var tail\n\n    if (value) {\n      tail = nodes[nodes.length - 1]\n\n      if (tail && tail.type === 'text') {\n        tail.value += value\n      } else {\n        nodes.push(buildText(value))\n      }\n    }\n\n    return nodes\n  }\n\n  // Build a text.\n  function buildText(value) {\n    return {type: 'text', value: value}\n  }\n\n  // Build a span.\n  function build(name, contents, noPrefix) {\n    return {\n      type: 'element',\n      tagName: 'span',\n      properties: {\n        className: [(noPrefix ? '' : prefix) + name]\n      },\n      children: contents\n    }\n  }\n\n  // Check if the first word in `keywords` is a keyword.\n  function keywordMatch(mode, keywords) {\n    var keyword = keywords[0]\n\n    if (language[keyInsensitive]) {\n      keyword = keyword.toLowerCase()\n    }\n\n    return own.call(mode.keywords, keyword) && mode.keywords[keyword]\n  }\n\n  // Check if `lexeme` is illegal according to `mode`.\n  function isIllegal(lexeme, mode) {\n    return !ignore && test(mode.illegalRe, lexeme)\n  }\n\n  // Check if `lexeme` ends `mode`.\n  function endOfMode(mode, lexeme) {\n    if (test(mode.endRe, lexeme)) {\n      while (mode.endsParent && mode.parent) {\n        mode = mode.parent\n      }\n\n      return mode\n    }\n\n    if (mode.endsWithParent) {\n      return endOfMode(mode.parent, lexeme)\n    }\n  }\n\n  // Check a sub-mode.\n  function subMode(lexeme, mode) {\n    var values = mode.contains\n    var length = values.length\n    var index = -1\n\n    while (++index < length) {\n      if (test(values[index].beginRe, lexeme)) {\n        return values[index]\n      }\n    }\n  }\n\n  // Exit the current context.\n  function pop() {\n    /* istanbul ignore next - removed in hljs 9.3 */\n    currentChildren = stack.pop() || children\n  }\n}\n\nfunction expandMode(mode) {\n  var length\n  var index\n  var variants\n  var result\n\n  if (mode.variants && !mode[keyCachedVariants]) {\n    variants = mode.variants\n    length = variants.length\n    index = -1\n    result = []\n\n    while (++index < length) {\n      result[index] = inherit(mode, {variants: null}, variants[index])\n    }\n\n    mode[keyCachedVariants] = result\n  }\n\n  return (\n    mode[keyCachedVariants] || (mode.endsWithParent ? [inherit(mode)] : [mode])\n  )\n}\n\n// Compile a language.\nfunction compileLanguage(language) {\n  compileMode(language)\n\n  // Compile a language mode, optionally with a parent.\n  // eslint-disable-next-line complexity\n  function compileMode(mode, parent) {\n    var compiledKeywords = {}\n    var terminators\n\n    if (mode.compiled) {\n      return\n    }\n\n    mode.compiled = true\n\n    mode.keywords = mode.keywords || mode.beginKeywords\n\n    if (mode.keywords) {\n      if (typeof mode.keywords === 'string') {\n        flatten('keyword', mode.keywords)\n      } else {\n        Object.keys(mode.keywords).forEach(function(className) {\n          flatten(className, mode.keywords[className])\n        })\n      }\n\n      mode.keywords = compiledKeywords\n    }\n\n    mode.lexemesRe = langRe(mode.lexemes || /\\w+/, true)\n\n    if (parent) {\n      if (mode.beginKeywords) {\n        mode.begin =\n          '\\\\b(' + mode.beginKeywords.split(space).join(verticalBar) + ')\\\\b'\n      }\n\n      if (!mode.begin) {\n        mode.begin = /\\B|\\b/\n      }\n\n      mode.beginRe = langRe(mode.begin)\n\n      if (!mode.end && !mode.endsWithParent) {\n        mode.end = /\\B|\\b/\n      }\n\n      if (mode.end) {\n        mode.endRe = langRe(mode.end)\n      }\n\n      mode.terminatorEnd = source(mode.end) || ''\n\n      if (mode.endsWithParent && parent.terminatorEnd) {\n        mode.terminatorEnd +=\n          (mode.end ? verticalBar : '') + parent.terminatorEnd\n      }\n    }\n\n    if (mode.illegal) {\n      mode.illegalRe = langRe(mode.illegal)\n    }\n\n    if (mode.relevance === undefined) {\n      mode.relevance = 1\n    }\n\n    if (!mode.contains) {\n      mode.contains = []\n    }\n\n    mode.contains = concat.apply(\n      [],\n      mode.contains.map(function(c) {\n        return expandMode(c === 'self' ? mode : c)\n      })\n    )\n\n    mode.contains.forEach(function(c) {\n      compileMode(c, mode)\n    })\n\n    if (mode.starts) {\n      compileMode(mode.starts, parent)\n    }\n\n    terminators = mode.contains\n      .map(map)\n      .concat([mode.terminatorEnd, mode.illegal])\n      .map(source)\n      .filter(Boolean)\n\n    mode.terminators =\n      terminators.length === 0\n        ? {exec: execNoop}\n        : langRe(terminators.join(verticalBar), true)\n\n    function map(c) {\n      return c.beginKeywords ? '\\\\.?(' + c.begin + ')\\\\.?' : c.begin\n    }\n\n    // Flatten a classname.\n    function flatten(className, value) {\n      var pairs\n      var pair\n      var index\n      var length\n\n      if (language[keyInsensitive]) {\n        value = value.toLowerCase()\n      }\n\n      pairs = value.split(space)\n      length = pairs.length\n      index = -1\n\n      while (++index < length) {\n        pair = pairs[index].split(verticalBar)\n\n        compiledKeywords[pair[0]] = [className, pair[1] ? Number(pair[1]) : 1]\n      }\n    }\n  }\n\n  // Create a regex for `value`.\n  function langRe(value, global) {\n    return new RegExp(\n      source(value),\n      'm' + (language[keyInsensitive] ? 'i' : '') + (global ? 'g' : '')\n    )\n  }\n\n  // Get the source of an expression or string.\n  function source(re) {\n    return (re && re.source) || re\n  }\n}\n\n// Normalize a syntax result.\nfunction normalize(result) {\n  return {\n    relevance: result.relevance || 0,\n    language: result.language || null,\n    value: result.value || []\n  }\n}\n\n// Check if `expression` matches `lexeme`.\nfunction test(expression, lexeme) {\n  var match = expression && expression.exec(lexeme)\n  return match && match.index === 0\n}\n\n// No-op exec.\nfunction execNoop() {\n  return null\n}\n\n// Get a language by `name`.\nfunction getLanguage(name) {\n  name = name.toLowerCase()\n\n  return languages[name] || languages[aliases[name]]\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}