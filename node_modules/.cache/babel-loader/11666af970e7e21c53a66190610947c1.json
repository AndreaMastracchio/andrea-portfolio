{"ast":null,"code":"'use strict';module.exports=reason;reason.displayName='reason';reason.aliases=[];function reason(Prism){Prism.languages.reason=Prism.languages.extend('clike',{comment:{pattern:/(^|[^\\\\])\\/\\*[\\s\\S]*?\\*\\//,lookbehind:true},string:{pattern:/\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\\\\\\r\\n\"])*\"/,greedy:true},// 'class-name' must be matched *after* 'constructor' defined below\n'class-name':/\\b[A-Z]\\w*/,keyword:/\\b(?:and|as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|method|module|mutable|new|nonrec|object|of|open|or|private|rec|sig|struct|switch|then|to|try|type|val|virtual|when|while|with)\\b/,operator:/\\.{3}|:[:=]|\\|>|->|=(?:==?|>)?|<=?|>=?|[|^?'#!~`]|[+\\-*\\/]\\.?|\\b(?:mod|land|lor|lxor|lsl|lsr|asr)\\b/});Prism.languages.insertBefore('reason','class-name',{character:{pattern:/'(?:\\\\x[\\da-f]{2}|\\\\o[0-3][0-7][0-7]|\\\\\\d{3}|\\\\.|[^'\\\\\\r\\n])'/,alias:'string'},constructor:{// Negative look-ahead prevents from matching things like String.capitalize\npattern:/\\b[A-Z]\\w*\\b(?!\\s*\\.)/,alias:'variable'},label:{pattern:/\\b[a-z]\\w*(?=::)/,alias:'symbol'}});// We can't match functions property, so let's not even try.\ndelete Prism.languages.reason.function;}","map":{"version":3,"names":["module","exports","reason","displayName","aliases","Prism","languages","extend","comment","pattern","lookbehind","string","greedy","keyword","operator","insertBefore","character","alias","constructor","label","function"],"sources":["/home/andrea/progetti/andrea-portfolio/frontend/node_modules/refractor/lang/reason.js"],"sourcesContent":["'use strict'\n\nmodule.exports = reason\nreason.displayName = 'reason'\nreason.aliases = []\nfunction reason(Prism) {\n  Prism.languages.reason = Prism.languages.extend('clike', {\n    comment: {\n      pattern: /(^|[^\\\\])\\/\\*[\\s\\S]*?\\*\\//,\n      lookbehind: true\n    },\n    string: {\n      pattern: /\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\\\\\\r\\n\"])*\"/,\n      greedy: true\n    },\n    // 'class-name' must be matched *after* 'constructor' defined below\n    'class-name': /\\b[A-Z]\\w*/,\n    keyword: /\\b(?:and|as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|method|module|mutable|new|nonrec|object|of|open|or|private|rec|sig|struct|switch|then|to|try|type|val|virtual|when|while|with)\\b/,\n    operator: /\\.{3}|:[:=]|\\|>|->|=(?:==?|>)?|<=?|>=?|[|^?'#!~`]|[+\\-*\\/]\\.?|\\b(?:mod|land|lor|lxor|lsl|lsr|asr)\\b/\n  })\n  Prism.languages.insertBefore('reason', 'class-name', {\n    character: {\n      pattern: /'(?:\\\\x[\\da-f]{2}|\\\\o[0-3][0-7][0-7]|\\\\\\d{3}|\\\\.|[^'\\\\\\r\\n])'/,\n      alias: 'string'\n    },\n    constructor: {\n      // Negative look-ahead prevents from matching things like String.capitalize\n      pattern: /\\b[A-Z]\\w*\\b(?!\\s*\\.)/,\n      alias: 'variable'\n    },\n    label: {\n      pattern: /\\b[a-z]\\w*(?=::)/,\n      alias: 'symbol'\n    }\n  }) // We can't match functions property, so let's not even try.\n  delete Prism.languages.reason.function\n}\n"],"mappings":"AAAA,aAEAA,MAAM,CAACC,OAAP,CAAiBC,MAAjB,CACAA,MAAM,CAACC,WAAP,CAAqB,QAArB,CACAD,MAAM,CAACE,OAAP,CAAiB,EAAjB,CACA,QAASF,OAAT,CAAgBG,KAAhB,CAAuB,CACrBA,KAAK,CAACC,SAAN,CAAgBJ,MAAhB,CAAyBG,KAAK,CAACC,SAAN,CAAgBC,MAAhB,CAAuB,OAAvB,CAAgC,CACvDC,OAAO,CAAE,CACPC,OAAO,CAAE,2BADF,CAEPC,UAAU,CAAE,IAFL,CAD8C,CAKvDC,MAAM,CAAE,CACNF,OAAO,CAAE,qCADH,CAENG,MAAM,CAAE,IAFF,CAL+C,CASvD;AACA,aAAc,YAVyC,CAWvDC,OAAO,CAAE,2RAX8C,CAYvDC,QAAQ,CAAE,qGAZ6C,CAAhC,CAAzB,CAcAT,KAAK,CAACC,SAAN,CAAgBS,YAAhB,CAA6B,QAA7B,CAAuC,YAAvC,CAAqD,CACnDC,SAAS,CAAE,CACTP,OAAO,CAAE,+DADA,CAETQ,KAAK,CAAE,QAFE,CADwC,CAKnDC,WAAW,CAAE,CACX;AACAT,OAAO,CAAE,uBAFE,CAGXQ,KAAK,CAAE,UAHI,CALsC,CAUnDE,KAAK,CAAE,CACLV,OAAO,CAAE,kBADJ,CAELQ,KAAK,CAAE,QAFF,CAV4C,CAArD,EAcG;AACH,MAAOZ,MAAK,CAACC,SAAN,CAAgBJ,MAAhB,CAAuBkB,QAA9B,CACD"},"metadata":{},"sourceType":"module"}