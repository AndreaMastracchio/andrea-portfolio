{"ast":null,"code":"import _slicedToArray from\"/home/andrea/progetti/andrea-portfolio/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";/**\n * React Router v6.3.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */import{parsePath,createMemoryHistory,Action}from'history';export{Action as NavigationType,createPath,parsePath}from'history';import{createContext,useContext,useMemo,useRef,useEffect,useCallback,createElement,useState,useLayoutEffect,Children,isValidElement,Fragment}from'react';var NavigationContext=/*#__PURE__*/createContext(null);if(process.env.NODE_ENV!==\"production\"){NavigationContext.displayName=\"Navigation\";}var LocationContext=/*#__PURE__*/createContext(null);if(process.env.NODE_ENV!==\"production\"){LocationContext.displayName=\"Location\";}var RouteContext=/*#__PURE__*/createContext({outlet:null,matches:[]});if(process.env.NODE_ENV!==\"production\"){RouteContext.displayName=\"Route\";}function invariant(cond,message){if(!cond)throw new Error(message);}function warning(cond,message){if(!cond){// eslint-disable-next-line no-console\nif(typeof console!==\"undefined\")console.warn(message);try{// Welcome to debugging React Router!\n//\n// This error is thrown as a convenience so you can more easily\n// find the source for a warning that appears in the console by\n// enabling \"pause on exceptions\" in your JavaScript debugger.\nthrow new Error(message);// eslint-disable-next-line no-empty\n}catch(e){}}}var alreadyWarned={};function warningOnce(key,cond,message){if(!cond&&!alreadyWarned[key]){alreadyWarned[key]=true;process.env.NODE_ENV!==\"production\"?warning(false,message):void 0;}}/**\n * Returns a path with params interpolated.\n *\n * @see https://reactrouter.com/docs/en/v6/api#generatepath\n */function generatePath(path,params){if(params===void 0){params={};}return path.replace(/:(\\w+)/g,function(_,key){!(params[key]!=null)?process.env.NODE_ENV!==\"production\"?invariant(false,\"Missing \\\":\"+key+\"\\\" param\"):invariant(false):void 0;return params[key];}).replace(/\\/*\\*$/,function(_){return params[\"*\"]==null?\"\":params[\"*\"].replace(/^\\/*/,\"/\");});}/**\n * A RouteMatch contains info about how a route matched a URL.\n */ /**\n * Matches the given routes to a location and returns the match data.\n *\n * @see https://reactrouter.com/docs/en/v6/api#matchroutes\n */function matchRoutes(routes,locationArg,basename){if(basename===void 0){basename=\"/\";}var location=typeof locationArg===\"string\"?parsePath(locationArg):locationArg;var pathname=stripBasename(location.pathname||\"/\",basename);if(pathname==null){return null;}var branches=flattenRoutes(routes);rankRouteBranches(branches);var matches=null;for(var i=0;matches==null&&i<branches.length;++i){matches=matchRouteBranch(branches[i],pathname);}return matches;}function flattenRoutes(routes,branches,parentsMeta,parentPath){if(branches===void 0){branches=[];}if(parentsMeta===void 0){parentsMeta=[];}if(parentPath===void 0){parentPath=\"\";}routes.forEach(function(route,index){var meta={relativePath:route.path||\"\",caseSensitive:route.caseSensitive===true,childrenIndex:index,route:route};if(meta.relativePath.startsWith(\"/\")){!meta.relativePath.startsWith(parentPath)?process.env.NODE_ENV!==\"production\"?invariant(false,\"Absolute route path \\\"\"+meta.relativePath+\"\\\" nested under path \"+(\"\\\"\"+parentPath+\"\\\" is not valid. An absolute child route path \")+\"must start with the combined path of all its parent routes.\"):invariant(false):void 0;meta.relativePath=meta.relativePath.slice(parentPath.length);}var path=joinPaths([parentPath,meta.relativePath]);var routesMeta=parentsMeta.concat(meta);// Add the children before adding this route to the array so we traverse the\n// route tree depth-first and child routes appear before their parents in\n// the \"flattened\" version.\nif(route.children&&route.children.length>0){!(route.index!==true)?process.env.NODE_ENV!==\"production\"?invariant(false,\"Index routes must not have child routes. Please remove \"+(\"all child routes from route path \\\"\"+path+\"\\\".\")):invariant(false):void 0;flattenRoutes(route.children,branches,routesMeta,path);}// Routes without a path shouldn't ever match by themselves unless they are\n// index routes, so don't add them to the list of possible branches.\nif(route.path==null&&!route.index){return;}branches.push({path:path,score:computeScore(path,route.index),routesMeta:routesMeta});});return branches;}function rankRouteBranches(branches){branches.sort(function(a,b){return a.score!==b.score?b.score-a.score// Higher score first\n:compareIndexes(a.routesMeta.map(function(meta){return meta.childrenIndex;}),b.routesMeta.map(function(meta){return meta.childrenIndex;}));});}var paramRe=/^:\\w+$/;var dynamicSegmentValue=3;var indexRouteValue=2;var emptySegmentValue=1;var staticSegmentValue=10;var splatPenalty=-2;var isSplat=function isSplat(s){return s===\"*\";};function computeScore(path,index){var segments=path.split(\"/\");var initialScore=segments.length;if(segments.some(isSplat)){initialScore+=splatPenalty;}if(index){initialScore+=indexRouteValue;}return segments.filter(function(s){return!isSplat(s);}).reduce(function(score,segment){return score+(paramRe.test(segment)?dynamicSegmentValue:segment===\"\"?emptySegmentValue:staticSegmentValue);},initialScore);}function compareIndexes(a,b){var siblings=a.length===b.length&&a.slice(0,-1).every(function(n,i){return n===b[i];});return siblings?// If two routes are siblings, we should try to match the earlier sibling\n// first. This allows people to have fine-grained control over the matching\n// behavior by simply putting routes with identical paths in the order they\n// want them tried.\na[a.length-1]-b[b.length-1]:// Otherwise, it doesn't really make sense to rank non-siblings by index,\n// so they sort equally.\n0;}function matchRouteBranch(branch,pathname){var routesMeta=branch.routesMeta;var matchedParams={};var matchedPathname=\"/\";var matches=[];for(var i=0;i<routesMeta.length;++i){var meta=routesMeta[i];var end=i===routesMeta.length-1;var remainingPathname=matchedPathname===\"/\"?pathname:pathname.slice(matchedPathname.length)||\"/\";var match=matchPath({path:meta.relativePath,caseSensitive:meta.caseSensitive,end:end},remainingPathname);if(!match)return null;Object.assign(matchedParams,match.params);var route=meta.route;matches.push({params:matchedParams,pathname:joinPaths([matchedPathname,match.pathname]),pathnameBase:normalizePathname(joinPaths([matchedPathname,match.pathnameBase])),route:route});if(match.pathnameBase!==\"/\"){matchedPathname=joinPaths([matchedPathname,match.pathnameBase]);}}return matches;}/**\n * A PathPattern is used to match on some portion of a URL pathname.\n */ /**\n * Performs pattern matching on a URL pathname and returns information about\n * the match.\n *\n * @see https://reactrouter.com/docs/en/v6/api#matchpath\n */function matchPath(pattern,pathname){if(typeof pattern===\"string\"){pattern={path:pattern,caseSensitive:false,end:true};}var _compilePath=compilePath(pattern.path,pattern.caseSensitive,pattern.end),_compilePath2=_slicedToArray(_compilePath,2),matcher=_compilePath2[0],paramNames=_compilePath2[1];var match=pathname.match(matcher);if(!match)return null;var matchedPathname=match[0];var pathnameBase=matchedPathname.replace(/(.)\\/+$/,\"$1\");var captureGroups=match.slice(1);var params=paramNames.reduce(function(memo,paramName,index){// We need to compute the pathnameBase here using the raw splat value\n// instead of using params[\"*\"] later because it will be decoded then\nif(paramName===\"*\"){var splatValue=captureGroups[index]||\"\";pathnameBase=matchedPathname.slice(0,matchedPathname.length-splatValue.length).replace(/(.)\\/+$/,\"$1\");}memo[paramName]=safelyDecodeURIComponent(captureGroups[index]||\"\",paramName);return memo;},{});return{params:params,pathname:matchedPathname,pathnameBase:pathnameBase,pattern:pattern};}function compilePath(path,caseSensitive,end){if(caseSensitive===void 0){caseSensitive=false;}if(end===void 0){end=true;}process.env.NODE_ENV!==\"production\"?warning(path===\"*\"||!path.endsWith(\"*\")||path.endsWith(\"/*\"),\"Route path \\\"\"+path+\"\\\" will be treated as if it were \"+(\"\\\"\"+path.replace(/\\*$/,\"/*\")+\"\\\" because the `*` character must \")+\"always follow a `/` in the pattern. To get rid of this warning, \"+(\"please change the route path to \\\"\"+path.replace(/\\*$/,\"/*\")+\"\\\".\")):void 0;var paramNames=[];var regexpSource=\"^\"+path.replace(/\\/*\\*?$/,\"\")// Ignore trailing / and /*, we'll handle it below\n.replace(/^\\/*/,\"/\")// Make sure it has a leading /\n.replace(/[\\\\.*+^$?{}|()[\\]]/g,\"\\\\$&\")// Escape special regex chars\n.replace(/:(\\w+)/g,function(_,paramName){paramNames.push(paramName);return\"([^\\\\/]+)\";});if(path.endsWith(\"*\")){paramNames.push(\"*\");regexpSource+=path===\"*\"||path===\"/*\"?\"(.*)$\"// Already matched the initial /, just match the rest\n:\"(?:\\\\/(.+)|\\\\/*)$\";// Don't include the / in params[\"*\"]\n}else{regexpSource+=end?\"\\\\/*$\"// When matching to the end, ignore trailing slashes\n:// Otherwise, match a word boundary or a proceeding /. The word boundary restricts\n// parent routes to matching only their own words and nothing more, e.g. parent\n// route \"/home\" should not match \"/home2\".\n// Additionally, allow paths starting with `.`, `-`, `~`, and url-encoded entities,\n// but do not consume the character in the matched path so they can match against\n// nested paths.\n\"(?:(?=[.~-]|%[0-9A-F]{2})|\\\\b|\\\\/|$)\";}var matcher=new RegExp(regexpSource,caseSensitive?undefined:\"i\");return[matcher,paramNames];}function safelyDecodeURIComponent(value,paramName){try{return decodeURIComponent(value);}catch(error){process.env.NODE_ENV!==\"production\"?warning(false,\"The value for the URL param \\\"\"+paramName+\"\\\" will not be decoded because\"+(\" the string \\\"\"+value+\"\\\" is a malformed URL segment. This is probably\")+(\" due to a bad percent encoding (\"+error+\").\")):void 0;return value;}}/**\n * Returns a resolved path object relative to the given pathname.\n *\n * @see https://reactrouter.com/docs/en/v6/api#resolvepath\n */function resolvePath(to,fromPathname){if(fromPathname===void 0){fromPathname=\"/\";}var _ref5=typeof to===\"string\"?parsePath(to):to,toPathname=_ref5.pathname,_ref5$search=_ref5.search,search=_ref5$search===void 0?\"\":_ref5$search,_ref5$hash=_ref5.hash,hash=_ref5$hash===void 0?\"\":_ref5$hash;var pathname=toPathname?toPathname.startsWith(\"/\")?toPathname:resolvePathname(toPathname,fromPathname):fromPathname;return{pathname:pathname,search:normalizeSearch(search),hash:normalizeHash(hash)};}function resolvePathname(relativePath,fromPathname){var segments=fromPathname.replace(/\\/+$/,\"\").split(\"/\");var relativeSegments=relativePath.split(\"/\");relativeSegments.forEach(function(segment){if(segment===\"..\"){// Keep the root \"\" segment so the pathname starts at /\nif(segments.length>1)segments.pop();}else if(segment!==\".\"){segments.push(segment);}});return segments.length>1?segments.join(\"/\"):\"/\";}function resolveTo(toArg,routePathnames,locationPathname){var to=typeof toArg===\"string\"?parsePath(toArg):toArg;var toPathname=toArg===\"\"||to.pathname===\"\"?\"/\":to.pathname;// If a pathname is explicitly provided in `to`, it should be relative to the\n// route context. This is explained in `Note on `<Link to>` values` in our\n// migration guide from v5 as a means of disambiguation between `to` values\n// that begin with `/` and those that do not. However, this is problematic for\n// `to` values that do not provide a pathname. `to` can simply be a search or\n// hash string, in which case we should assume that the navigation is relative\n// to the current location's pathname and *not* the route pathname.\nvar from;if(toPathname==null){from=locationPathname;}else{var routePathnameIndex=routePathnames.length-1;if(toPathname.startsWith(\"..\")){var toSegments=toPathname.split(\"/\");// Each leading .. segment means \"go up one route\" instead of \"go up one\n// URL segment\".  This is a key difference from how <a href> works and a\n// major reason we call this a \"to\" value instead of a \"href\".\nwhile(toSegments[0]===\"..\"){toSegments.shift();routePathnameIndex-=1;}to.pathname=toSegments.join(\"/\");}// If there are more \"..\" segments than parent routes, resolve relative to\n// the root / URL.\nfrom=routePathnameIndex>=0?routePathnames[routePathnameIndex]:\"/\";}var path=resolvePath(to,from);// Ensure the pathname has a trailing slash if the original to value had one.\nif(toPathname&&toPathname!==\"/\"&&toPathname.endsWith(\"/\")&&!path.pathname.endsWith(\"/\")){path.pathname+=\"/\";}return path;}function getToPathname(to){// Empty strings should be treated the same as / paths\nreturn to===\"\"||to.pathname===\"\"?\"/\":typeof to===\"string\"?parsePath(to).pathname:to.pathname;}function stripBasename(pathname,basename){if(basename===\"/\")return pathname;if(!pathname.toLowerCase().startsWith(basename.toLowerCase())){return null;}var nextChar=pathname.charAt(basename.length);if(nextChar&&nextChar!==\"/\"){// pathname does not start with basename/\nreturn null;}return pathname.slice(basename.length)||\"/\";}var joinPaths=function joinPaths(paths){return paths.join(\"/\").replace(/\\/\\/+/g,\"/\");};var normalizePathname=function normalizePathname(pathname){return pathname.replace(/\\/+$/,\"\").replace(/^\\/*/,\"/\");};var normalizeSearch=function normalizeSearch(search){return!search||search===\"?\"?\"\":search.startsWith(\"?\")?search:\"?\"+search;};var normalizeHash=function normalizeHash(hash){return!hash||hash===\"#\"?\"\":hash.startsWith(\"#\")?hash:\"#\"+hash;};/**\n * Returns the full href for the given \"to\" value. This is useful for building\n * custom links that are also accessible and preserve right-click behavior.\n *\n * @see https://reactrouter.com/docs/en/v6/api#usehref\n */function useHref(to){!useInRouterContext()?process.env.NODE_ENV!==\"production\"?invariant(false,// TODO: This error is probably because they somehow have 2 versions of the\n// router loaded. We can help them understand how to avoid that.\n\"useHref() may be used only in the context of a <Router> component.\"):invariant(false):void 0;var _useContext=useContext(NavigationContext),basename=_useContext.basename,navigator=_useContext.navigator;var _useResolvedPath=useResolvedPath(to),hash=_useResolvedPath.hash,pathname=_useResolvedPath.pathname,search=_useResolvedPath.search;var joinedPathname=pathname;if(basename!==\"/\"){var toPathname=getToPathname(to);var endsWithSlash=toPathname!=null&&toPathname.endsWith(\"/\");joinedPathname=pathname===\"/\"?basename+(endsWithSlash?\"/\":\"\"):joinPaths([basename,pathname]);}return navigator.createHref({pathname:joinedPathname,search:search,hash:hash});}/**\n * Returns true if this component is a descendant of a <Router>.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useinroutercontext\n */function useInRouterContext(){return useContext(LocationContext)!=null;}/**\n * Returns the current location object, which represents the current URL in web\n * browsers.\n *\n * Note: If you're using this it may mean you're doing some of your own\n * \"routing\" in your app, and we'd like to know what your use case is. We may\n * be able to provide something higher-level to better suit your needs.\n *\n * @see https://reactrouter.com/docs/en/v6/api#uselocation\n */function useLocation(){!useInRouterContext()?process.env.NODE_ENV!==\"production\"?invariant(false,// TODO: This error is probably because they somehow have 2 versions of the\n// router loaded. We can help them understand how to avoid that.\n\"useLocation() may be used only in the context of a <Router> component.\"):invariant(false):void 0;return useContext(LocationContext).location;}/**\n * Returns the current navigation action which describes how the router came to\n * the current location, either by a pop, push, or replace on the history stack.\n *\n * @see https://reactrouter.com/docs/en/v6/api#usenavigationtype\n */function useNavigationType(){return useContext(LocationContext).navigationType;}/**\n * Returns true if the URL for the given \"to\" value matches the current URL.\n * This is useful for components that need to know \"active\" state, e.g.\n * <NavLink>.\n *\n * @see https://reactrouter.com/docs/en/v6/api#usematch\n */function useMatch(pattern){!useInRouterContext()?process.env.NODE_ENV!==\"production\"?invariant(false,// TODO: This error is probably because they somehow have 2 versions of the\n// router loaded. We can help them understand how to avoid that.\n\"useMatch() may be used only in the context of a <Router> component.\"):invariant(false):void 0;var _useLocation=useLocation(),pathname=_useLocation.pathname;return useMemo(function(){return matchPath(pattern,pathname);},[pathname,pattern]);}/**\n * The interface for the navigate() function returned from useNavigate().\n */ /**\n * Returns an imperative method for changing the location. Used by <Link>s, but\n * may also be used by other elements to change the location.\n *\n * @see https://reactrouter.com/docs/en/v6/api#usenavigate\n */function useNavigate(){!useInRouterContext()?process.env.NODE_ENV!==\"production\"?invariant(false,// TODO: This error is probably because they somehow have 2 versions of the\n// router loaded. We can help them understand how to avoid that.\n\"useNavigate() may be used only in the context of a <Router> component.\"):invariant(false):void 0;var _useContext2=useContext(NavigationContext),basename=_useContext2.basename,navigator=_useContext2.navigator;var _useContext3=useContext(RouteContext),matches=_useContext3.matches;var _useLocation2=useLocation(),locationPathname=_useLocation2.pathname;var routePathnamesJson=JSON.stringify(matches.map(function(match){return match.pathnameBase;}));var activeRef=useRef(false);useEffect(function(){activeRef.current=true;});var navigate=useCallback(function(to,options){if(options===void 0){options={};}process.env.NODE_ENV!==\"production\"?warning(activeRef.current,\"You should call navigate() in a React.useEffect(), not when \"+\"your component is first rendered.\"):void 0;if(!activeRef.current)return;if(typeof to===\"number\"){navigator.go(to);return;}var path=resolveTo(to,JSON.parse(routePathnamesJson),locationPathname);if(basename!==\"/\"){path.pathname=joinPaths([basename,path.pathname]);}(!!options.replace?navigator.replace:navigator.push)(path,options.state);},[basename,navigator,routePathnamesJson,locationPathname]);return navigate;}var OutletContext=/*#__PURE__*/createContext(null);/**\n * Returns the context (if provided) for the child route at this level of the route\n * hierarchy.\n * @see https://reactrouter.com/docs/en/v6/api#useoutletcontext\n */function useOutletContext(){return useContext(OutletContext);}/**\n * Returns the element for the child route at this level of the route\n * hierarchy. Used internally by <Outlet> to render child routes.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useoutlet\n */function useOutlet(context){var outlet=useContext(RouteContext).outlet;if(outlet){return/*#__PURE__*/createElement(OutletContext.Provider,{value:context},outlet);}return outlet;}/**\n * Returns an object of key/value pairs of the dynamic params from the current\n * URL that were matched by the route path.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useparams\n */function useParams(){var _useContext4=useContext(RouteContext),matches=_useContext4.matches;var routeMatch=matches[matches.length-1];return routeMatch?routeMatch.params:{};}/**\n * Resolves the pathname of the given `to` value against the current location.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useresolvedpath\n */function useResolvedPath(to){var _useContext5=useContext(RouteContext),matches=_useContext5.matches;var _useLocation3=useLocation(),locationPathname=_useLocation3.pathname;var routePathnamesJson=JSON.stringify(matches.map(function(match){return match.pathnameBase;}));return useMemo(function(){return resolveTo(to,JSON.parse(routePathnamesJson),locationPathname);},[to,routePathnamesJson,locationPathname]);}/**\n * Returns the element of the route that matched the current location, prepared\n * with the correct context to render the remainder of the route tree. Route\n * elements in the tree must render an <Outlet> to render their child route's\n * element.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useroutes\n */function useRoutes(routes,locationArg){!useInRouterContext()?process.env.NODE_ENV!==\"production\"?invariant(false,// TODO: This error is probably because they somehow have 2 versions of the\n// router loaded. We can help them understand how to avoid that.\n\"useRoutes() may be used only in the context of a <Router> component.\"):invariant(false):void 0;var _useContext6=useContext(RouteContext),parentMatches=_useContext6.matches;var routeMatch=parentMatches[parentMatches.length-1];var parentParams=routeMatch?routeMatch.params:{};var parentPathname=routeMatch?routeMatch.pathname:\"/\";var parentPathnameBase=routeMatch?routeMatch.pathnameBase:\"/\";var parentRoute=routeMatch&&routeMatch.route;if(process.env.NODE_ENV!==\"production\"){// You won't get a warning about 2 different <Routes> under a <Route>\n// without a trailing *, but this is a best-effort warning anyway since we\n// cannot even give the warning unless they land at the parent route.\n//\n// Example:\n//\n// <Routes>\n//   {/* This route path MUST end with /* because otherwise\n//       it will never match /blog/post/123 */}\n//   <Route path=\"blog\" element={<Blog />} />\n//   <Route path=\"blog/feed\" element={<BlogFeed />} />\n// </Routes>\n//\n// function Blog() {\n//   return (\n//     <Routes>\n//       <Route path=\"post/:id\" element={<Post />} />\n//     </Routes>\n//   );\n// }\nvar parentPath=parentRoute&&parentRoute.path||\"\";warningOnce(parentPathname,!parentRoute||parentPath.endsWith(\"*\"),\"You rendered descendant <Routes> (or called `useRoutes()`) at \"+(\"\\\"\"+parentPathname+\"\\\" (under <Route path=\\\"\"+parentPath+\"\\\">) but the \")+\"parent route path has no trailing \\\"*\\\". This means if you navigate \"+\"deeper, the parent won't match anymore and therefore the child \"+\"routes will never render.\\n\\n\"+(\"Please change the parent <Route path=\\\"\"+parentPath+\"\\\"> to <Route \")+(\"path=\\\"\"+(parentPath===\"/\"?\"*\":parentPath+\"/*\")+\"\\\">.\"));}var locationFromContext=useLocation();var location;if(locationArg){var _parsedLocationArg$pa;var parsedLocationArg=typeof locationArg===\"string\"?parsePath(locationArg):locationArg;!(parentPathnameBase===\"/\"||((_parsedLocationArg$pa=parsedLocationArg.pathname)==null?void 0:_parsedLocationArg$pa.startsWith(parentPathnameBase)))?process.env.NODE_ENV!==\"production\"?invariant(false,\"When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, \"+\"the location pathname must begin with the portion of the URL pathname that was \"+(\"matched by all parent routes. The current pathname base is \\\"\"+parentPathnameBase+\"\\\" \")+(\"but pathname \\\"\"+parsedLocationArg.pathname+\"\\\" was given in the `location` prop.\")):invariant(false):void 0;location=parsedLocationArg;}else{location=locationFromContext;}var pathname=location.pathname||\"/\";var remainingPathname=parentPathnameBase===\"/\"?pathname:pathname.slice(parentPathnameBase.length)||\"/\";var matches=matchRoutes(routes,{pathname:remainingPathname});if(process.env.NODE_ENV!==\"production\"){process.env.NODE_ENV!==\"production\"?warning(parentRoute||matches!=null,\"No routes matched location \\\"\"+location.pathname+location.search+location.hash+\"\\\" \"):void 0;process.env.NODE_ENV!==\"production\"?warning(matches==null||matches[matches.length-1].route.element!==undefined,\"Matched leaf route at location \\\"\"+location.pathname+location.search+location.hash+\"\\\" does not have an element. \"+\"This means it will render an <Outlet /> with a null value by default resulting in an \\\"empty\\\" page.\"):void 0;}return _renderMatches(matches&&matches.map(function(match){return Object.assign({},match,{params:Object.assign({},parentParams,match.params),pathname:joinPaths([parentPathnameBase,match.pathname]),pathnameBase:match.pathnameBase===\"/\"?parentPathnameBase:joinPaths([parentPathnameBase,match.pathnameBase])});}),parentMatches);}function _renderMatches(matches,parentMatches){if(parentMatches===void 0){parentMatches=[];}if(matches==null)return null;return matches.reduceRight(function(outlet,match,index){return/*#__PURE__*/createElement(RouteContext.Provider,{children:match.route.element!==undefined?match.route.element:outlet,value:{outlet:outlet,matches:parentMatches.concat(matches.slice(0,index+1))}});},null);}/**\n * A <Router> that stores all entries in memory.\n *\n * @see https://reactrouter.com/docs/en/v6/api#memoryrouter\n */function MemoryRouter(_ref){var basename=_ref.basename,children=_ref.children,initialEntries=_ref.initialEntries,initialIndex=_ref.initialIndex;var historyRef=useRef();if(historyRef.current==null){historyRef.current=createMemoryHistory({initialEntries:initialEntries,initialIndex:initialIndex});}var history=historyRef.current;var _useState=useState({action:history.action,location:history.location}),_useState2=_slicedToArray(_useState,2),state=_useState2[0],setState=_useState2[1];useLayoutEffect(function(){return history.listen(setState);},[history]);return/*#__PURE__*/createElement(Router,{basename:basename,children:children,location:state.location,navigationType:state.action,navigator:history});}/**\n * Changes the current location.\n *\n * Note: This API is mostly useful in React.Component subclasses that are not\n * able to use hooks. In functional components, we recommend you use the\n * `useNavigate` hook instead.\n *\n * @see https://reactrouter.com/docs/en/v6/api#navigate\n */function Navigate(_ref2){var to=_ref2.to,replace=_ref2.replace,state=_ref2.state;!useInRouterContext()?process.env.NODE_ENV!==\"production\"?invariant(false,// TODO: This error is probably because they somehow have 2 versions of\n// the router loaded. We can help them understand how to avoid that.\n\"<Navigate> may be used only in the context of a <Router> component.\"):invariant(false):void 0;process.env.NODE_ENV!==\"production\"?warning(!useContext(NavigationContext).static,\"<Navigate> must not be used on the initial render in a <StaticRouter>. \"+\"This is a no-op, but you should modify your code so the <Navigate> is \"+\"only ever rendered in response to some user interaction or state change.\"):void 0;var navigate=useNavigate();useEffect(function(){navigate(to,{replace:replace,state:state});});return null;}/**\n * Renders the child route's element, if there is one.\n *\n * @see https://reactrouter.com/docs/en/v6/api#outlet\n */function Outlet(props){return useOutlet(props.context);}/**\n * Declares an element that should be rendered at a certain URL path.\n *\n * @see https://reactrouter.com/docs/en/v6/api#route\n */function Route(_props){process.env.NODE_ENV!==\"production\"?invariant(false,\"A <Route> is only ever to be used as the child of <Routes> element, \"+\"never rendered directly. Please wrap your <Route> in a <Routes>.\"):invariant(false);}/**\n * Provides location context for the rest of the app.\n *\n * Note: You usually won't render a <Router> directly. Instead, you'll render a\n * router that is more specific to your environment such as a <BrowserRouter>\n * in web browsers or a <StaticRouter> for server rendering.\n *\n * @see https://reactrouter.com/docs/en/v6/api#router\n */function Router(_ref3){var _ref3$basename=_ref3.basename,basenameProp=_ref3$basename===void 0?\"/\":_ref3$basename,_ref3$children=_ref3.children,children=_ref3$children===void 0?null:_ref3$children,locationProp=_ref3.location,_ref3$navigationType=_ref3.navigationType,navigationType=_ref3$navigationType===void 0?Action.Pop:_ref3$navigationType,navigator=_ref3.navigator,_ref3$static=_ref3.static,staticProp=_ref3$static===void 0?false:_ref3$static;!!useInRouterContext()?process.env.NODE_ENV!==\"production\"?invariant(false,\"You cannot render a <Router> inside another <Router>.\"+\" You should never have more than one in your app.\"):invariant(false):void 0;var basename=normalizePathname(basenameProp);var navigationContext=useMemo(function(){return{basename:basename,navigator:navigator,static:staticProp};},[basename,navigator,staticProp]);if(typeof locationProp===\"string\"){locationProp=parsePath(locationProp);}var _locationProp=locationProp,_locationProp$pathnam=_locationProp.pathname,pathname=_locationProp$pathnam===void 0?\"/\":_locationProp$pathnam,_locationProp$search=_locationProp.search,search=_locationProp$search===void 0?\"\":_locationProp$search,_locationProp$hash=_locationProp.hash,hash=_locationProp$hash===void 0?\"\":_locationProp$hash,_locationProp$state=_locationProp.state,state=_locationProp$state===void 0?null:_locationProp$state,_locationProp$key=_locationProp.key,key=_locationProp$key===void 0?\"default\":_locationProp$key;var location=useMemo(function(){var trailingPathname=stripBasename(pathname,basename);if(trailingPathname==null){return null;}return{pathname:trailingPathname,search:search,hash:hash,state:state,key:key};},[basename,pathname,search,hash,state,key]);process.env.NODE_ENV!==\"production\"?warning(location!=null,\"<Router basename=\\\"\"+basename+\"\\\"> is not able to match the URL \"+(\"\\\"\"+pathname+search+hash+\"\\\" because it does not start with the \")+\"basename, so the <Router> won't render anything.\"):void 0;if(location==null){return null;}return/*#__PURE__*/createElement(NavigationContext.Provider,{value:navigationContext},/*#__PURE__*/createElement(LocationContext.Provider,{children:children,value:{location:location,navigationType:navigationType}}));}/**\n * A container for a nested tree of <Route> elements that renders the branch\n * that best matches the current location.\n *\n * @see https://reactrouter.com/docs/en/v6/api#routes\n */function Routes(_ref4){var children=_ref4.children,location=_ref4.location;return useRoutes(createRoutesFromChildren(children),location);}///////////////////////////////////////////////////////////////////////////////\n// UTILS\n///////////////////////////////////////////////////////////////////////////////\n/**\n * Creates a route config from a React \"children\" object, which is usually\n * either a `<Route>` element or an array of them. Used internally by\n * `<Routes>` to create a route config from its children.\n *\n * @see https://reactrouter.com/docs/en/v6/api#createroutesfromchildren\n */function createRoutesFromChildren(children){var routes=[];Children.forEach(children,function(element){if(!/*#__PURE__*/isValidElement(element)){// Ignore non-elements. This allows people to more easily inline\n// conditionals in their route config.\nreturn;}if(element.type===Fragment){// Transparently support React.Fragment and its children.\nroutes.push.apply(routes,createRoutesFromChildren(element.props.children));return;}!(element.type===Route)?process.env.NODE_ENV!==\"production\"?invariant(false,\"[\"+(typeof element.type===\"string\"?element.type:element.type.name)+\"] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>\"):invariant(false):void 0;var route={caseSensitive:element.props.caseSensitive,element:element.props.element,index:element.props.index,path:element.props.path};if(element.props.children){route.children=createRoutesFromChildren(element.props.children);}routes.push(route);});return routes;}/**\n * Renders the result of `matchRoutes()` into a React element.\n */function renderMatches(matches){return _renderMatches(matches);}export{MemoryRouter,Navigate,Outlet,Route,Router,Routes,LocationContext as UNSAFE_LocationContext,NavigationContext as UNSAFE_NavigationContext,RouteContext as UNSAFE_RouteContext,createRoutesFromChildren,generatePath,matchPath,matchRoutes,renderMatches,resolvePath,useHref,useInRouterContext,useLocation,useMatch,useNavigate,useNavigationType,useOutlet,useOutletContext,useParams,useResolvedPath,useRoutes};","map":{"version":3,"mappings":"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","names":["NavigationContext","React","displayName","LocationContext","RouteContext","outlet","matches","invariant","cond","message","Error","warning","console","warn","e","alreadyWarned","warningOnce","key","process","generatePath","path","params","replace","_","matchRoutes","routes","locationArg","basename","location","parsePath","pathname","stripBasename","branches","flattenRoutes","rankRouteBranches","i","length","matchRouteBranch","parentsMeta","parentPath","forEach","route","index","meta","relativePath","caseSensitive","childrenIndex","startsWith","slice","joinPaths","routesMeta","concat","children","push","score","computeScore","sort","a","b","compareIndexes","map","paramRe","dynamicSegmentValue","indexRouteValue","emptySegmentValue","staticSegmentValue","splatPenalty","isSplat","s","segments","split","initialScore","some","filter","reduce","segment","test","siblings","every","n","branch","matchedParams","matchedPathname","end","remainingPathname","match","matchPath","Object","assign","pathnameBase","normalizePathname","pattern","compilePath","matcher","paramNames","captureGroups","memo","paramName","splatValue","safelyDecodeURIComponent","endsWith","regexpSource","RegExp","undefined","value","decodeURIComponent","error","resolvePath","to","fromPathname","toPathname","search","hash","resolvePathname","normalizeSearch","normalizeHash","relativeSegments","pop","join","resolveTo","toArg","routePathnames","locationPathname","from","routePathnameIndex","toSegments","shift","getToPathname","toLowerCase","nextChar","charAt","paths","useHref","useInRouterContext","navigator","useResolvedPath","joinedPathname","endsWithSlash","createHref","useLocation","useNavigationType","navigationType","useMatch","useNavigate","routePathnamesJson","JSON","stringify","activeRef","current","navigate","options","go","parse","state","OutletContext","useOutletContext","useOutlet","context","React.createElement","Provider","useParams","routeMatch","useRoutes","parentMatches","parentParams","parentPathname","parentPathnameBase","parentRoute","locationFromContext","parsedLocationArg","_parsedLocationArg$pa","element","_renderMatches","reduceRight","MemoryRouter","_ref","initialEntries","initialIndex","historyRef","createMemoryHistory","history","action","setState","listen","Router","Navigate","_ref2","static","Outlet","props","Route","_props","_ref3","basenameProp","locationProp","NavigationType","Pop","staticProp","navigationContext","trailingPathname","Routes","_ref4","createRoutesFromChildren","type","apply","name","renderMatches"],"sources":["/home/andrea/progetti/andrea-portfolio/packages/react-router/lib/context.ts","/home/andrea/progetti/andrea-portfolio/packages/react-router/lib/router.ts","/home/andrea/progetti/andrea-portfolio/packages/react-router/lib/hooks.tsx","/home/andrea/progetti/andrea-portfolio/packages/react-router/lib/components.tsx"],"sourcesContent":["import * as React from \"react\";\nimport type { History, Location } from \"history\";\nimport { Action as NavigationType } from \"history\";\n\nimport type { RouteMatch } from \"./router\";\n\n/**\n * A Navigator is a \"location changer\"; it's how you get to different locations.\n *\n * Every history instance conforms to the Navigator interface, but the\n * distinction is useful primarily when it comes to the low-level <Router> API\n * where both the location and a navigator must be provided separately in order\n * to avoid \"tearing\" that may occur in a suspense-enabled app if the action\n * and/or location were to be read directly from the history instance.\n */\nexport type Navigator = Pick<History, \"go\" | \"push\" | \"replace\" | \"createHref\">;\n\ninterface NavigationContextObject {\n  basename: string;\n  navigator: Navigator;\n  static: boolean;\n}\n\nexport const NavigationContext = React.createContext<NavigationContextObject>(\n  null!\n);\n\nif (__DEV__) {\n  NavigationContext.displayName = \"Navigation\";\n}\n\ninterface LocationContextObject {\n  location: Location;\n  navigationType: NavigationType;\n}\n\nexport const LocationContext = React.createContext<LocationContextObject>(\n  null!\n);\n\nif (__DEV__) {\n  LocationContext.displayName = \"Location\";\n}\n\ninterface RouteContextObject {\n  outlet: React.ReactElement | null;\n  matches: RouteMatch[];\n}\n\nexport const RouteContext = React.createContext<RouteContextObject>({\n  outlet: null,\n  matches: [],\n});\n\nif (__DEV__) {\n  RouteContext.displayName = \"Route\";\n}\n","import type { Location, Path, To } from \"history\";\nimport { parsePath } from \"history\";\n\nexport function invariant(cond: any, message: string): asserts cond {\n  if (!cond) throw new Error(message);\n}\n\nexport function warning(cond: any, message: string): void {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== \"undefined\") console.warn(message);\n\n    try {\n      // Welcome to debugging React Router!\n      //\n      // This error is thrown as a convenience so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message);\n      // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\n\nconst alreadyWarned: Record<string, boolean> = {};\nexport function warningOnce(key: string, cond: boolean, message: string) {\n  if (!cond && !alreadyWarned[key]) {\n    alreadyWarned[key] = true;\n    warning(false, message);\n  }\n}\n\ntype ParamParseFailed = { failed: true };\n\ntype ParamParseSegment<Segment extends string> =\n  // Check here if there exists a forward slash in the string.\n  Segment extends `${infer LeftSegment}/${infer RightSegment}`\n    ? // If there is a forward slash, then attempt to parse each side of the\n      // forward slash.\n      ParamParseSegment<LeftSegment> extends infer LeftResult\n      ? ParamParseSegment<RightSegment> extends infer RightResult\n        ? LeftResult extends string\n          ? // If the left side is successfully parsed as a param, then check if\n            // the right side can be successfully parsed as well. If both sides\n            // can be parsed, then the result is a union of the two sides\n            // (read: \"foo\" | \"bar\").\n            RightResult extends string\n            ? LeftResult | RightResult\n            : LeftResult\n          : // If the left side is not successfully parsed as a param, then check\n          // if only the right side can be successfully parse as a param. If it\n          // can, then the result is just right, else it's a failure.\n          RightResult extends string\n          ? RightResult\n          : ParamParseFailed\n        : ParamParseFailed\n      : // If the left side didn't parse into a param, then just check the right\n      // side.\n      ParamParseSegment<RightSegment> extends infer RightResult\n      ? RightResult extends string\n        ? RightResult\n        : ParamParseFailed\n      : ParamParseFailed\n    : // If there's no forward slash, then check if this segment starts with a\n    // colon. If it does, then this is a dynamic segment, so the result is\n    // just the remainder of the string. Otherwise, it's a failure.\n    Segment extends `:${infer Remaining}`\n    ? Remaining\n    : ParamParseFailed;\n\n// Attempt to parse the given string segment. If it fails, then just return the\n// plain string type as a default fallback. Otherwise return the union of the\n// parsed string literals that were referenced as dynamic segments in the route.\nexport type ParamParseKey<Segment extends string> =\n  ParamParseSegment<Segment> extends string\n    ? ParamParseSegment<Segment>\n    : string;\n\n/**\n * The parameters that were parsed from the URL path.\n */\nexport type Params<Key extends string = string> = {\n  readonly [key in Key]: string | undefined;\n};\n\n/**\n * A route object represents a logical route, with (optionally) its child\n * routes organized in a tree-like structure.\n */\nexport interface RouteObject {\n  caseSensitive?: boolean;\n  children?: RouteObject[];\n  element?: React.ReactNode;\n  index?: boolean;\n  path?: string;\n}\n\n/**\n * Returns a path with params interpolated.\n *\n * @see https://reactrouter.com/docs/en/v6/api#generatepath\n */\nexport function generatePath(path: string, params: Params = {}): string {\n  return path\n    .replace(/:(\\w+)/g, (_, key) => {\n      invariant(params[key] != null, `Missing \":${key}\" param`);\n      return params[key]!;\n    })\n    .replace(/\\/*\\*$/, (_) =>\n      params[\"*\"] == null ? \"\" : params[\"*\"].replace(/^\\/*/, \"/\")\n    );\n}\n\n/**\n * A RouteMatch contains info about how a route matched a URL.\n */\nexport interface RouteMatch<ParamKey extends string = string> {\n  /**\n   * The names and values of dynamic parameters in the URL.\n   */\n  params: Params<ParamKey>;\n  /**\n   * The portion of the URL pathname that was matched.\n   */\n  pathname: string;\n  /**\n   * The portion of the URL pathname that was matched before child routes.\n   */\n  pathnameBase: string;\n  /**\n   * The route object that was used to match.\n   */\n  route: RouteObject;\n}\n\n/**\n * Matches the given routes to a location and returns the match data.\n *\n * @see https://reactrouter.com/docs/en/v6/api#matchroutes\n */\nexport function matchRoutes(\n  routes: RouteObject[],\n  locationArg: Partial<Location> | string,\n  basename = \"/\"\n): RouteMatch[] | null {\n  let location =\n    typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n\n  let pathname = stripBasename(location.pathname || \"/\", basename);\n\n  if (pathname == null) {\n    return null;\n  }\n\n  let branches = flattenRoutes(routes);\n  rankRouteBranches(branches);\n\n  let matches = null;\n  for (let i = 0; matches == null && i < branches.length; ++i) {\n    matches = matchRouteBranch(branches[i], pathname);\n  }\n\n  return matches;\n}\n\ninterface RouteMeta {\n  relativePath: string;\n  caseSensitive: boolean;\n  childrenIndex: number;\n  route: RouteObject;\n}\n\ninterface RouteBranch {\n  path: string;\n  score: number;\n  routesMeta: RouteMeta[];\n}\n\nfunction flattenRoutes(\n  routes: RouteObject[],\n  branches: RouteBranch[] = [],\n  parentsMeta: RouteMeta[] = [],\n  parentPath = \"\"\n): RouteBranch[] {\n  routes.forEach((route, index) => {\n    let meta: RouteMeta = {\n      relativePath: route.path || \"\",\n      caseSensitive: route.caseSensitive === true,\n      childrenIndex: index,\n      route,\n    };\n\n    if (meta.relativePath.startsWith(\"/\")) {\n      invariant(\n        meta.relativePath.startsWith(parentPath),\n        `Absolute route path \"${meta.relativePath}\" nested under path ` +\n          `\"${parentPath}\" is not valid. An absolute child route path ` +\n          `must start with the combined path of all its parent routes.`\n      );\n\n      meta.relativePath = meta.relativePath.slice(parentPath.length);\n    }\n\n    let path = joinPaths([parentPath, meta.relativePath]);\n    let routesMeta = parentsMeta.concat(meta);\n\n    // Add the children before adding this route to the array so we traverse the\n    // route tree depth-first and child routes appear before their parents in\n    // the \"flattened\" version.\n    if (route.children && route.children.length > 0) {\n      invariant(\n        route.index !== true,\n        `Index routes must not have child routes. Please remove ` +\n          `all child routes from route path \"${path}\".`\n      );\n\n      flattenRoutes(route.children, branches, routesMeta, path);\n    }\n\n    // Routes without a path shouldn't ever match by themselves unless they are\n    // index routes, so don't add them to the list of possible branches.\n    if (route.path == null && !route.index) {\n      return;\n    }\n\n    branches.push({ path, score: computeScore(path, route.index), routesMeta });\n  });\n\n  return branches;\n}\n\nfunction rankRouteBranches(branches: RouteBranch[]): void {\n  branches.sort((a, b) =>\n    a.score !== b.score\n      ? b.score - a.score // Higher score first\n      : compareIndexes(\n          a.routesMeta.map((meta) => meta.childrenIndex),\n          b.routesMeta.map((meta) => meta.childrenIndex)\n        )\n  );\n}\n\nconst paramRe = /^:\\w+$/;\nconst dynamicSegmentValue = 3;\nconst indexRouteValue = 2;\nconst emptySegmentValue = 1;\nconst staticSegmentValue = 10;\nconst splatPenalty = -2;\nconst isSplat = (s: string) => s === \"*\";\n\nfunction computeScore(path: string, index: boolean | undefined): number {\n  let segments = path.split(\"/\");\n  let initialScore = segments.length;\n  if (segments.some(isSplat)) {\n    initialScore += splatPenalty;\n  }\n\n  if (index) {\n    initialScore += indexRouteValue;\n  }\n\n  return segments\n    .filter((s) => !isSplat(s))\n    .reduce(\n      (score, segment) =>\n        score +\n        (paramRe.test(segment)\n          ? dynamicSegmentValue\n          : segment === \"\"\n          ? emptySegmentValue\n          : staticSegmentValue),\n      initialScore\n    );\n}\n\nfunction compareIndexes(a: number[], b: number[]): number {\n  let siblings =\n    a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);\n\n  return siblings\n    ? // If two routes are siblings, we should try to match the earlier sibling\n      // first. This allows people to have fine-grained control over the matching\n      // behavior by simply putting routes with identical paths in the order they\n      // want them tried.\n      a[a.length - 1] - b[b.length - 1]\n    : // Otherwise, it doesn't really make sense to rank non-siblings by index,\n      // so they sort equally.\n      0;\n}\n\nfunction matchRouteBranch<ParamKey extends string = string>(\n  branch: RouteBranch,\n  pathname: string\n): RouteMatch<ParamKey>[] | null {\n  let { routesMeta } = branch;\n\n  let matchedParams = {};\n  let matchedPathname = \"/\";\n  let matches: RouteMatch[] = [];\n  for (let i = 0; i < routesMeta.length; ++i) {\n    let meta = routesMeta[i];\n    let end = i === routesMeta.length - 1;\n    let remainingPathname =\n      matchedPathname === \"/\"\n        ? pathname\n        : pathname.slice(matchedPathname.length) || \"/\";\n    let match = matchPath(\n      { path: meta.relativePath, caseSensitive: meta.caseSensitive, end },\n      remainingPathname\n    );\n\n    if (!match) return null;\n\n    Object.assign(matchedParams, match.params);\n\n    let route = meta.route;\n\n    matches.push({\n      params: matchedParams,\n      pathname: joinPaths([matchedPathname, match.pathname]),\n      pathnameBase: normalizePathname(\n        joinPaths([matchedPathname, match.pathnameBase])\n      ),\n      route,\n    });\n\n    if (match.pathnameBase !== \"/\") {\n      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);\n    }\n  }\n\n  return matches;\n}\n\n/**\n * A PathPattern is used to match on some portion of a URL pathname.\n */\nexport interface PathPattern<Path extends string = string> {\n  /**\n   * A string to match against a URL pathname. May contain `:id`-style segments\n   * to indicate placeholders for dynamic parameters. May also end with `/*` to\n   * indicate matching the rest of the URL pathname.\n   */\n  path: Path;\n  /**\n   * Should be `true` if the static portions of the `path` should be matched in\n   * the same case.\n   */\n  caseSensitive?: boolean;\n  /**\n   * Should be `true` if this pattern should match the entire URL pathname.\n   */\n  end?: boolean;\n}\n\n/**\n * A PathMatch contains info about how a PathPattern matched on a URL pathname.\n */\nexport interface PathMatch<ParamKey extends string = string> {\n  /**\n   * The names and values of dynamic parameters in the URL.\n   */\n  params: Params<ParamKey>;\n  /**\n   * The portion of the URL pathname that was matched.\n   */\n  pathname: string;\n  /**\n   * The portion of the URL pathname that was matched before child routes.\n   */\n  pathnameBase: string;\n  /**\n   * The pattern that was used to match.\n   */\n  pattern: PathPattern;\n}\n\ntype Mutable<T> = {\n  -readonly [P in keyof T]: T[P];\n};\n\n/**\n * Performs pattern matching on a URL pathname and returns information about\n * the match.\n *\n * @see https://reactrouter.com/docs/en/v6/api#matchpath\n */\nexport function matchPath<\n  ParamKey extends ParamParseKey<Path>,\n  Path extends string\n>(\n  pattern: PathPattern<Path> | Path,\n  pathname: string\n): PathMatch<ParamKey> | null {\n  if (typeof pattern === \"string\") {\n    pattern = { path: pattern, caseSensitive: false, end: true };\n  }\n\n  let [matcher, paramNames] = compilePath(\n    pattern.path,\n    pattern.caseSensitive,\n    pattern.end\n  );\n\n  let match = pathname.match(matcher);\n  if (!match) return null;\n\n  let matchedPathname = match[0];\n  let pathnameBase = matchedPathname.replace(/(.)\\/+$/, \"$1\");\n  let captureGroups = match.slice(1);\n  let params: Params = paramNames.reduce<Mutable<Params>>(\n    (memo, paramName, index) => {\n      // We need to compute the pathnameBase here using the raw splat value\n      // instead of using params[\"*\"] later because it will be decoded then\n      if (paramName === \"*\") {\n        let splatValue = captureGroups[index] || \"\";\n        pathnameBase = matchedPathname\n          .slice(0, matchedPathname.length - splatValue.length)\n          .replace(/(.)\\/+$/, \"$1\");\n      }\n\n      memo[paramName] = safelyDecodeURIComponent(\n        captureGroups[index] || \"\",\n        paramName\n      );\n      return memo;\n    },\n    {}\n  );\n\n  return {\n    params,\n    pathname: matchedPathname,\n    pathnameBase,\n    pattern,\n  };\n}\n\nfunction compilePath(\n  path: string,\n  caseSensitive = false,\n  end = true\n): [RegExp, string[]] {\n  warning(\n    path === \"*\" || !path.endsWith(\"*\") || path.endsWith(\"/*\"),\n    `Route path \"${path}\" will be treated as if it were ` +\n      `\"${path.replace(/\\*$/, \"/*\")}\" because the \\`*\\` character must ` +\n      `always follow a \\`/\\` in the pattern. To get rid of this warning, ` +\n      `please change the route path to \"${path.replace(/\\*$/, \"/*\")}\".`\n  );\n\n  let paramNames: string[] = [];\n  let regexpSource =\n    \"^\" +\n    path\n      .replace(/\\/*\\*?$/, \"\") // Ignore trailing / and /*, we'll handle it below\n      .replace(/^\\/*/, \"/\") // Make sure it has a leading /\n      .replace(/[\\\\.*+^$?{}|()[\\]]/g, \"\\\\$&\") // Escape special regex chars\n      .replace(/:(\\w+)/g, (_: string, paramName: string) => {\n        paramNames.push(paramName);\n        return \"([^\\\\/]+)\";\n      });\n\n  if (path.endsWith(\"*\")) {\n    paramNames.push(\"*\");\n    regexpSource +=\n      path === \"*\" || path === \"/*\"\n        ? \"(.*)$\" // Already matched the initial /, just match the rest\n        : \"(?:\\\\/(.+)|\\\\/*)$\"; // Don't include the / in params[\"*\"]\n  } else {\n    regexpSource += end\n      ? \"\\\\/*$\" // When matching to the end, ignore trailing slashes\n      : // Otherwise, match a word boundary or a proceeding /. The word boundary restricts\n        // parent routes to matching only their own words and nothing more, e.g. parent\n        // route \"/home\" should not match \"/home2\".\n        // Additionally, allow paths starting with `.`, `-`, `~`, and url-encoded entities,\n        // but do not consume the character in the matched path so they can match against\n        // nested paths.\n        \"(?:(?=[.~-]|%[0-9A-F]{2})|\\\\b|\\\\/|$)\";\n  }\n\n  let matcher = new RegExp(regexpSource, caseSensitive ? undefined : \"i\");\n\n  return [matcher, paramNames];\n}\n\nfunction safelyDecodeURIComponent(value: string, paramName: string) {\n  try {\n    return decodeURIComponent(value);\n  } catch (error) {\n    warning(\n      false,\n      `The value for the URL param \"${paramName}\" will not be decoded because` +\n        ` the string \"${value}\" is a malformed URL segment. This is probably` +\n        ` due to a bad percent encoding (${error}).`\n    );\n\n    return value;\n  }\n}\n\n/**\n * Returns a resolved path object relative to the given pathname.\n *\n * @see https://reactrouter.com/docs/en/v6/api#resolvepath\n */\nexport function resolvePath(to: To, fromPathname = \"/\"): Path {\n  let {\n    pathname: toPathname,\n    search = \"\",\n    hash = \"\",\n  } = typeof to === \"string\" ? parsePath(to) : to;\n\n  let pathname = toPathname\n    ? toPathname.startsWith(\"/\")\n      ? toPathname\n      : resolvePathname(toPathname, fromPathname)\n    : fromPathname;\n\n  return {\n    pathname,\n    search: normalizeSearch(search),\n    hash: normalizeHash(hash),\n  };\n}\n\nfunction resolvePathname(relativePath: string, fromPathname: string): string {\n  let segments = fromPathname.replace(/\\/+$/, \"\").split(\"/\");\n  let relativeSegments = relativePath.split(\"/\");\n\n  relativeSegments.forEach((segment) => {\n    if (segment === \"..\") {\n      // Keep the root \"\" segment so the pathname starts at /\n      if (segments.length > 1) segments.pop();\n    } else if (segment !== \".\") {\n      segments.push(segment);\n    }\n  });\n\n  return segments.length > 1 ? segments.join(\"/\") : \"/\";\n}\n\nexport function resolveTo(\n  toArg: To,\n  routePathnames: string[],\n  locationPathname: string\n): Path {\n  let to = typeof toArg === \"string\" ? parsePath(toArg) : toArg;\n  let toPathname = toArg === \"\" || to.pathname === \"\" ? \"/\" : to.pathname;\n\n  // If a pathname is explicitly provided in `to`, it should be relative to the\n  // route context. This is explained in `Note on `<Link to>` values` in our\n  // migration guide from v5 as a means of disambiguation between `to` values\n  // that begin with `/` and those that do not. However, this is problematic for\n  // `to` values that do not provide a pathname. `to` can simply be a search or\n  // hash string, in which case we should assume that the navigation is relative\n  // to the current location's pathname and *not* the route pathname.\n  let from: string;\n  if (toPathname == null) {\n    from = locationPathname;\n  } else {\n    let routePathnameIndex = routePathnames.length - 1;\n\n    if (toPathname.startsWith(\"..\")) {\n      let toSegments = toPathname.split(\"/\");\n\n      // Each leading .. segment means \"go up one route\" instead of \"go up one\n      // URL segment\".  This is a key difference from how <a href> works and a\n      // major reason we call this a \"to\" value instead of a \"href\".\n      while (toSegments[0] === \"..\") {\n        toSegments.shift();\n        routePathnameIndex -= 1;\n      }\n\n      to.pathname = toSegments.join(\"/\");\n    }\n\n    // If there are more \"..\" segments than parent routes, resolve relative to\n    // the root / URL.\n    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : \"/\";\n  }\n\n  let path = resolvePath(to, from);\n\n  // Ensure the pathname has a trailing slash if the original to value had one.\n  if (\n    toPathname &&\n    toPathname !== \"/\" &&\n    toPathname.endsWith(\"/\") &&\n    !path.pathname.endsWith(\"/\")\n  ) {\n    path.pathname += \"/\";\n  }\n\n  return path;\n}\n\nexport function getToPathname(to: To): string | undefined {\n  // Empty strings should be treated the same as / paths\n  return to === \"\" || (to as Path).pathname === \"\"\n    ? \"/\"\n    : typeof to === \"string\"\n    ? parsePath(to).pathname\n    : to.pathname;\n}\n\nexport function stripBasename(\n  pathname: string,\n  basename: string\n): string | null {\n  if (basename === \"/\") return pathname;\n\n  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\n    return null;\n  }\n\n  let nextChar = pathname.charAt(basename.length);\n  if (nextChar && nextChar !== \"/\") {\n    // pathname does not start with basename/\n    return null;\n  }\n\n  return pathname.slice(basename.length) || \"/\";\n}\n\nexport const joinPaths = (paths: string[]): string =>\n  paths.join(\"/\").replace(/\\/\\/+/g, \"/\");\n\nexport const normalizePathname = (pathname: string): string =>\n  pathname.replace(/\\/+$/, \"\").replace(/^\\/*/, \"/\");\n\nconst normalizeSearch = (search: string): string =>\n  !search || search === \"?\"\n    ? \"\"\n    : search.startsWith(\"?\")\n    ? search\n    : \"?\" + search;\n\nconst normalizeHash = (hash: string): string =>\n  !hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash;\n","import * as React from \"react\";\nimport type { Location, Path, To } from \"history\";\nimport { Action as NavigationType, parsePath } from \"history\";\n\nimport { LocationContext, NavigationContext, RouteContext } from \"./context\";\nimport type {\n  ParamParseKey,\n  Params,\n  PathMatch,\n  PathPattern,\n  RouteMatch,\n  RouteObject,\n} from \"./router\";\nimport {\n  getToPathname,\n  invariant,\n  joinPaths,\n  matchPath,\n  matchRoutes,\n  resolveTo,\n  warning,\n  warningOnce,\n} from \"./router\";\n\n/**\n * Returns the full href for the given \"to\" value. This is useful for building\n * custom links that are also accessible and preserve right-click behavior.\n *\n * @see https://reactrouter.com/docs/en/v6/api#usehref\n */\nexport function useHref(to: To): string {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useHref() may be used only in the context of a <Router> component.`\n  );\n\n  let { basename, navigator } = React.useContext(NavigationContext);\n  let { hash, pathname, search } = useResolvedPath(to);\n\n  let joinedPathname = pathname;\n  if (basename !== \"/\") {\n    let toPathname = getToPathname(to);\n    let endsWithSlash = toPathname != null && toPathname.endsWith(\"/\");\n    joinedPathname =\n      pathname === \"/\"\n        ? basename + (endsWithSlash ? \"/\" : \"\")\n        : joinPaths([basename, pathname]);\n  }\n\n  return navigator.createHref({ pathname: joinedPathname, search, hash });\n}\n\n/**\n * Returns true if this component is a descendant of a <Router>.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useinroutercontext\n */\nexport function useInRouterContext(): boolean {\n  return React.useContext(LocationContext) != null;\n}\n\n/**\n * Returns the current location object, which represents the current URL in web\n * browsers.\n *\n * Note: If you're using this it may mean you're doing some of your own\n * \"routing\" in your app, and we'd like to know what your use case is. We may\n * be able to provide something higher-level to better suit your needs.\n *\n * @see https://reactrouter.com/docs/en/v6/api#uselocation\n */\nexport function useLocation(): Location {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useLocation() may be used only in the context of a <Router> component.`\n  );\n\n  return React.useContext(LocationContext).location;\n}\n\n/**\n * Returns the current navigation action which describes how the router came to\n * the current location, either by a pop, push, or replace on the history stack.\n *\n * @see https://reactrouter.com/docs/en/v6/api#usenavigationtype\n */\nexport function useNavigationType(): NavigationType {\n  return React.useContext(LocationContext).navigationType;\n}\n\n/**\n * Returns true if the URL for the given \"to\" value matches the current URL.\n * This is useful for components that need to know \"active\" state, e.g.\n * <NavLink>.\n *\n * @see https://reactrouter.com/docs/en/v6/api#usematch\n */\nexport function useMatch<\n  ParamKey extends ParamParseKey<Path>,\n  Path extends string\n>(pattern: PathPattern<Path> | Path): PathMatch<ParamKey> | null {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useMatch() may be used only in the context of a <Router> component.`\n  );\n\n  let { pathname } = useLocation();\n  return React.useMemo(\n    () => matchPath<ParamKey, Path>(pattern, pathname),\n    [pathname, pattern]\n  );\n}\n\n/**\n * The interface for the navigate() function returned from useNavigate().\n */\nexport interface NavigateFunction {\n  (to: To, options?: NavigateOptions): void;\n  (delta: number): void;\n}\n\nexport interface NavigateOptions {\n  replace?: boolean;\n  state?: any;\n}\n\n/**\n * Returns an imperative method for changing the location. Used by <Link>s, but\n * may also be used by other elements to change the location.\n *\n * @see https://reactrouter.com/docs/en/v6/api#usenavigate\n */\nexport function useNavigate(): NavigateFunction {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useNavigate() may be used only in the context of a <Router> component.`\n  );\n\n  let { basename, navigator } = React.useContext(NavigationContext);\n  let { matches } = React.useContext(RouteContext);\n  let { pathname: locationPathname } = useLocation();\n\n  let routePathnamesJson = JSON.stringify(\n    matches.map((match) => match.pathnameBase)\n  );\n\n  let activeRef = React.useRef(false);\n  React.useEffect(() => {\n    activeRef.current = true;\n  });\n\n  let navigate: NavigateFunction = React.useCallback(\n    (to: To | number, options: NavigateOptions = {}) => {\n      warning(\n        activeRef.current,\n        `You should call navigate() in a React.useEffect(), not when ` +\n          `your component is first rendered.`\n      );\n\n      if (!activeRef.current) return;\n\n      if (typeof to === \"number\") {\n        navigator.go(to);\n        return;\n      }\n\n      let path = resolveTo(\n        to,\n        JSON.parse(routePathnamesJson),\n        locationPathname\n      );\n\n      if (basename !== \"/\") {\n        path.pathname = joinPaths([basename, path.pathname]);\n      }\n\n      (!!options.replace ? navigator.replace : navigator.push)(\n        path,\n        options.state\n      );\n    },\n    [basename, navigator, routePathnamesJson, locationPathname]\n  );\n\n  return navigate;\n}\n\nconst OutletContext = React.createContext<unknown>(null);\n\n/**\n * Returns the context (if provided) for the child route at this level of the route\n * hierarchy.\n * @see https://reactrouter.com/docs/en/v6/api#useoutletcontext\n */\nexport function useOutletContext<Context = unknown>(): Context {\n  return React.useContext(OutletContext) as Context;\n}\n\n/**\n * Returns the element for the child route at this level of the route\n * hierarchy. Used internally by <Outlet> to render child routes.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useoutlet\n */\nexport function useOutlet(context?: unknown): React.ReactElement | null {\n  let outlet = React.useContext(RouteContext).outlet;\n  if (outlet) {\n    return (\n      <OutletContext.Provider value={context}>{outlet}</OutletContext.Provider>\n    );\n  }\n  return outlet;\n}\n\n/**\n * Returns an object of key/value pairs of the dynamic params from the current\n * URL that were matched by the route path.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useparams\n */\nexport function useParams<\n  ParamsOrKey extends string | Record<string, string | undefined> = string\n>(): Readonly<\n  [ParamsOrKey] extends [string] ? Params<ParamsOrKey> : Partial<ParamsOrKey>\n> {\n  let { matches } = React.useContext(RouteContext);\n  let routeMatch = matches[matches.length - 1];\n  return routeMatch ? (routeMatch.params as any) : {};\n}\n\n/**\n * Resolves the pathname of the given `to` value against the current location.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useresolvedpath\n */\nexport function useResolvedPath(to: To): Path {\n  let { matches } = React.useContext(RouteContext);\n  let { pathname: locationPathname } = useLocation();\n\n  let routePathnamesJson = JSON.stringify(\n    matches.map((match) => match.pathnameBase)\n  );\n\n  return React.useMemo(\n    () => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname),\n    [to, routePathnamesJson, locationPathname]\n  );\n}\n\n/**\n * Returns the element of the route that matched the current location, prepared\n * with the correct context to render the remainder of the route tree. Route\n * elements in the tree must render an <Outlet> to render their child route's\n * element.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useroutes\n */\nexport function useRoutes(\n  routes: RouteObject[],\n  locationArg?: Partial<Location> | string\n): React.ReactElement | null {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useRoutes() may be used only in the context of a <Router> component.`\n  );\n\n  let { matches: parentMatches } = React.useContext(RouteContext);\n  let routeMatch = parentMatches[parentMatches.length - 1];\n  let parentParams = routeMatch ? routeMatch.params : {};\n  let parentPathname = routeMatch ? routeMatch.pathname : \"/\";\n  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : \"/\";\n  let parentRoute = routeMatch && routeMatch.route;\n\n  if (__DEV__) {\n    // You won't get a warning about 2 different <Routes> under a <Route>\n    // without a trailing *, but this is a best-effort warning anyway since we\n    // cannot even give the warning unless they land at the parent route.\n    //\n    // Example:\n    //\n    // <Routes>\n    //   {/* This route path MUST end with /* because otherwise\n    //       it will never match /blog/post/123 */}\n    //   <Route path=\"blog\" element={<Blog />} />\n    //   <Route path=\"blog/feed\" element={<BlogFeed />} />\n    // </Routes>\n    //\n    // function Blog() {\n    //   return (\n    //     <Routes>\n    //       <Route path=\"post/:id\" element={<Post />} />\n    //     </Routes>\n    //   );\n    // }\n    let parentPath = (parentRoute && parentRoute.path) || \"\";\n    warningOnce(\n      parentPathname,\n      !parentRoute || parentPath.endsWith(\"*\"),\n      `You rendered descendant <Routes> (or called \\`useRoutes()\\`) at ` +\n        `\"${parentPathname}\" (under <Route path=\"${parentPath}\">) but the ` +\n        `parent route path has no trailing \"*\". This means if you navigate ` +\n        `deeper, the parent won't match anymore and therefore the child ` +\n        `routes will never render.\\n\\n` +\n        `Please change the parent <Route path=\"${parentPath}\"> to <Route ` +\n        `path=\"${parentPath === \"/\" ? \"*\" : `${parentPath}/*`}\">.`\n    );\n  }\n\n  let locationFromContext = useLocation();\n\n  let location;\n  if (locationArg) {\n    let parsedLocationArg =\n      typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n\n    invariant(\n      parentPathnameBase === \"/\" ||\n        parsedLocationArg.pathname?.startsWith(parentPathnameBase),\n      `When overriding the location using \\`<Routes location>\\` or \\`useRoutes(routes, location)\\`, ` +\n        `the location pathname must begin with the portion of the URL pathname that was ` +\n        `matched by all parent routes. The current pathname base is \"${parentPathnameBase}\" ` +\n        `but pathname \"${parsedLocationArg.pathname}\" was given in the \\`location\\` prop.`\n    );\n\n    location = parsedLocationArg;\n  } else {\n    location = locationFromContext;\n  }\n\n  let pathname = location.pathname || \"/\";\n  let remainingPathname =\n    parentPathnameBase === \"/\"\n      ? pathname\n      : pathname.slice(parentPathnameBase.length) || \"/\";\n  let matches = matchRoutes(routes, { pathname: remainingPathname });\n\n  if (__DEV__) {\n    warning(\n      parentRoute || matches != null,\n      `No routes matched location \"${location.pathname}${location.search}${location.hash}\" `\n    );\n\n    warning(\n      matches == null ||\n        matches[matches.length - 1].route.element !== undefined,\n      `Matched leaf route at location \"${location.pathname}${location.search}${location.hash}\" does not have an element. ` +\n        `This means it will render an <Outlet /> with a null value by default resulting in an \"empty\" page.`\n    );\n  }\n\n  return _renderMatches(\n    matches &&\n      matches.map((match) =>\n        Object.assign({}, match, {\n          params: Object.assign({}, parentParams, match.params),\n          pathname: joinPaths([parentPathnameBase, match.pathname]),\n          pathnameBase:\n            match.pathnameBase === \"/\"\n              ? parentPathnameBase\n              : joinPaths([parentPathnameBase, match.pathnameBase]),\n        })\n      ),\n    parentMatches\n  );\n}\n\nexport function _renderMatches(\n  matches: RouteMatch[] | null,\n  parentMatches: RouteMatch[] = []\n): React.ReactElement | null {\n  if (matches == null) return null;\n\n  return matches.reduceRight((outlet, match, index) => {\n    return (\n      <RouteContext.Provider\n        children={\n          match.route.element !== undefined ? match.route.element : outlet\n        }\n        value={{\n          outlet,\n          matches: parentMatches.concat(matches.slice(0, index + 1)),\n        }}\n      />\n    );\n  }, null as React.ReactElement | null);\n}\n","import * as React from \"react\";\nimport type { InitialEntry, Location, MemoryHistory, To } from \"history\";\nimport {\n  Action as NavigationType,\n  createMemoryHistory,\n  parsePath,\n} from \"history\";\n\nimport { LocationContext, NavigationContext, Navigator } from \"./context\";\nimport {\n  useInRouterContext,\n  useNavigate,\n  useOutlet,\n  useRoutes,\n  _renderMatches,\n} from \"./hooks\";\nimport type { RouteMatch, RouteObject } from \"./router\";\nimport { invariant, normalizePathname, stripBasename, warning } from \"./router\";\n\nexport interface MemoryRouterProps {\n  basename?: string;\n  children?: React.ReactNode;\n  initialEntries?: InitialEntry[];\n  initialIndex?: number;\n}\n\n/**\n * A <Router> that stores all entries in memory.\n *\n * @see https://reactrouter.com/docs/en/v6/api#memoryrouter\n */\nexport function MemoryRouter({\n  basename,\n  children,\n  initialEntries,\n  initialIndex,\n}: MemoryRouterProps): React.ReactElement {\n  let historyRef = React.useRef<MemoryHistory>();\n  if (historyRef.current == null) {\n    historyRef.current = createMemoryHistory({ initialEntries, initialIndex });\n  }\n\n  let history = historyRef.current;\n  let [state, setState] = React.useState({\n    action: history.action,\n    location: history.location,\n  });\n\n  React.useLayoutEffect(() => history.listen(setState), [history]);\n\n  return (\n    <Router\n      basename={basename}\n      children={children}\n      location={state.location}\n      navigationType={state.action}\n      navigator={history}\n    />\n  );\n}\n\nexport interface NavigateProps {\n  to: To;\n  replace?: boolean;\n  state?: any;\n}\n\n/**\n * Changes the current location.\n *\n * Note: This API is mostly useful in React.Component subclasses that are not\n * able to use hooks. In functional components, we recommend you use the\n * `useNavigate` hook instead.\n *\n * @see https://reactrouter.com/docs/en/v6/api#navigate\n */\nexport function Navigate({ to, replace, state }: NavigateProps): null {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of\n    // the router loaded. We can help them understand how to avoid that.\n    `<Navigate> may be used only in the context of a <Router> component.`\n  );\n\n  warning(\n    !React.useContext(NavigationContext).static,\n    `<Navigate> must not be used on the initial render in a <StaticRouter>. ` +\n      `This is a no-op, but you should modify your code so the <Navigate> is ` +\n      `only ever rendered in response to some user interaction or state change.`\n  );\n\n  let navigate = useNavigate();\n  React.useEffect(() => {\n    navigate(to, { replace, state });\n  });\n\n  return null;\n}\n\nexport interface OutletProps {\n  context?: unknown;\n}\n\n/**\n * Renders the child route's element, if there is one.\n *\n * @see https://reactrouter.com/docs/en/v6/api#outlet\n */\nexport function Outlet(props: OutletProps): React.ReactElement | null {\n  return useOutlet(props.context);\n}\n\nexport interface RouteProps {\n  caseSensitive?: boolean;\n  children?: React.ReactNode;\n  element?: React.ReactNode | null;\n  index?: boolean;\n  path?: string;\n}\n\nexport interface PathRouteProps {\n  caseSensitive?: boolean;\n  children?: React.ReactNode;\n  element?: React.ReactNode | null;\n  index?: false;\n  path: string;\n}\n\nexport interface LayoutRouteProps {\n  children?: React.ReactNode;\n  element?: React.ReactNode | null;\n}\n\nexport interface IndexRouteProps {\n  element?: React.ReactNode | null;\n  index: true;\n}\n\n/**\n * Declares an element that should be rendered at a certain URL path.\n *\n * @see https://reactrouter.com/docs/en/v6/api#route\n */\nexport function Route(\n  _props: PathRouteProps | LayoutRouteProps | IndexRouteProps\n): React.ReactElement | null {\n  invariant(\n    false,\n    `A <Route> is only ever to be used as the child of <Routes> element, ` +\n      `never rendered directly. Please wrap your <Route> in a <Routes>.`\n  );\n}\n\nexport interface RouterProps {\n  basename?: string;\n  children?: React.ReactNode;\n  location: Partial<Location> | string;\n  navigationType?: NavigationType;\n  navigator: Navigator;\n  static?: boolean;\n}\n\n/**\n * Provides location context for the rest of the app.\n *\n * Note: You usually won't render a <Router> directly. Instead, you'll render a\n * router that is more specific to your environment such as a <BrowserRouter>\n * in web browsers or a <StaticRouter> for server rendering.\n *\n * @see https://reactrouter.com/docs/en/v6/api#router\n */\nexport function Router({\n  basename: basenameProp = \"/\",\n  children = null,\n  location: locationProp,\n  navigationType = NavigationType.Pop,\n  navigator,\n  static: staticProp = false,\n}: RouterProps): React.ReactElement | null {\n  invariant(\n    !useInRouterContext(),\n    `You cannot render a <Router> inside another <Router>.` +\n      ` You should never have more than one in your app.`\n  );\n\n  let basename = normalizePathname(basenameProp);\n  let navigationContext = React.useMemo(\n    () => ({ basename, navigator, static: staticProp }),\n    [basename, navigator, staticProp]\n  );\n\n  if (typeof locationProp === \"string\") {\n    locationProp = parsePath(locationProp);\n  }\n\n  let {\n    pathname = \"/\",\n    search = \"\",\n    hash = \"\",\n    state = null,\n    key = \"default\",\n  } = locationProp;\n\n  let location = React.useMemo(() => {\n    let trailingPathname = stripBasename(pathname, basename);\n\n    if (trailingPathname == null) {\n      return null;\n    }\n\n    return {\n      pathname: trailingPathname,\n      search,\n      hash,\n      state,\n      key,\n    };\n  }, [basename, pathname, search, hash, state, key]);\n\n  warning(\n    location != null,\n    `<Router basename=\"${basename}\"> is not able to match the URL ` +\n      `\"${pathname}${search}${hash}\" because it does not start with the ` +\n      `basename, so the <Router> won't render anything.`\n  );\n\n  if (location == null) {\n    return null;\n  }\n\n  return (\n    <NavigationContext.Provider value={navigationContext}>\n      <LocationContext.Provider\n        children={children}\n        value={{ location, navigationType }}\n      />\n    </NavigationContext.Provider>\n  );\n}\n\nexport interface RoutesProps {\n  children?: React.ReactNode;\n  location?: Partial<Location> | string;\n}\n\n/**\n * A container for a nested tree of <Route> elements that renders the branch\n * that best matches the current location.\n *\n * @see https://reactrouter.com/docs/en/v6/api#routes\n */\nexport function Routes({\n  children,\n  location,\n}: RoutesProps): React.ReactElement | null {\n  return useRoutes(createRoutesFromChildren(children), location);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// UTILS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Creates a route config from a React \"children\" object, which is usually\n * either a `<Route>` element or an array of them. Used internally by\n * `<Routes>` to create a route config from its children.\n *\n * @see https://reactrouter.com/docs/en/v6/api#createroutesfromchildren\n */\nexport function createRoutesFromChildren(\n  children: React.ReactNode\n): RouteObject[] {\n  let routes: RouteObject[] = [];\n\n  React.Children.forEach(children, (element) => {\n    if (!React.isValidElement(element)) {\n      // Ignore non-elements. This allows people to more easily inline\n      // conditionals in their route config.\n      return;\n    }\n\n    if (element.type === React.Fragment) {\n      // Transparently support React.Fragment and its children.\n      routes.push.apply(\n        routes,\n        createRoutesFromChildren(element.props.children)\n      );\n      return;\n    }\n\n    invariant(\n      element.type === Route,\n      `[${\n        typeof element.type === \"string\" ? element.type : element.type.name\n      }] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`\n    );\n\n    let route: RouteObject = {\n      caseSensitive: element.props.caseSensitive,\n      element: element.props.element,\n      index: element.props.index,\n      path: element.props.path,\n    };\n\n    if (element.props.children) {\n      route.children = createRoutesFromChildren(element.props.children);\n    }\n\n    routes.push(route);\n  });\n\n  return routes;\n}\n\n/**\n * Renders the result of `matchRoutes()` into a React element.\n */\nexport function renderMatches(\n  matches: RouteMatch[] | null\n): React.ReactElement | null {\n  return _renderMatches(matches);\n}\n"]},"metadata":{},"sourceType":"module"}