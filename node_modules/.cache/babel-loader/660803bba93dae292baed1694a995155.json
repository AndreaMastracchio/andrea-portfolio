{"ast":null,"code":"'use strict';module.exports=jsTemplates;jsTemplates.displayName='jsTemplates';jsTemplates.aliases=[];function jsTemplates(Prism){;(function(Prism){var templateString=Prism.languages.javascript['template-string'];// see the pattern in prism-javascript.js\nvar templateLiteralPattern=templateString.pattern.source;var interpolationObject=templateString.inside['interpolation'];var interpolationPunctuationObject=interpolationObject.inside['interpolation-punctuation'];var interpolationPattern=interpolationObject.pattern.source;/**\n     * Creates a new pattern to match a template string with a special tag.\n     *\n     * This will return `undefined` if there is no grammar with the given language id.\n     *\n     * @param {string} language The language id of the embedded language. E.g. `markdown`.\n     * @param {string} tag The regex pattern to match the tag.\n     * @returns {object | undefined}\n     * @example\n     * createTemplate('css', /\\bcss/.source);\n     */function createTemplate(language,tag){if(!Prism.languages[language]){return undefined;}return{pattern:RegExp('((?:'+tag+')\\\\s*)'+templateLiteralPattern),lookbehind:true,greedy:true,inside:{'template-punctuation':{pattern:/^`|`$/,alias:'string'},'embedded-code':{pattern:/[\\s\\S]+/,alias:language}}};}Prism.languages.javascript['template-string']=[// styled-jsx:\n//   css`a { color: #25F; }`\n// styled-components:\n//   styled.h1`color: red;`\ncreateTemplate('css',/\\b(?:styled(?:\\([^)]*\\))?(?:\\s*\\.\\s*\\w+(?:\\([^)]*\\))*)*|css(?:\\s*\\.\\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source),// html`<p></p>`\n// div.innerHTML = `<p></p>`\ncreateTemplate('html',/\\bhtml|\\.\\s*(?:inner|outer)HTML\\s*\\+?=/.source),// svg`<path fill=\"#fff\" d=\"M55.37 ...\"/>`\ncreateTemplate('svg',/\\bsvg/.source),// md`# h1`, markdown`## h2`\ncreateTemplate('markdown',/\\b(?:md|markdown)/.source),// gql`...`, graphql`...`, graphql.experimental`...`\ncreateTemplate('graphql',/\\b(?:gql|graphql(?:\\s*\\.\\s*experimental)?)/.source),// vanilla template string\ntemplateString].filter(Boolean);/**\n     * Returns a specific placeholder literal for the given language.\n     *\n     * @param {number} counter\n     * @param {string} language\n     * @returns {string}\n     */function getPlaceholder(counter,language){return'___'+language.toUpperCase()+'_'+counter+'___';}/**\n     * Returns the tokens of `Prism.tokenize` but also runs the `before-tokenize` and `after-tokenize` hooks.\n     *\n     * @param {string} code\n     * @param {any} grammar\n     * @param {string} language\n     * @returns {(string|Token)[]}\n     */function tokenizeWithHooks(code,grammar,language){var env={code:code,grammar:grammar,language:language};Prism.hooks.run('before-tokenize',env);env.tokens=Prism.tokenize(env.code,env.grammar);Prism.hooks.run('after-tokenize',env);return env.tokens;}/**\n     * Returns the token of the given JavaScript interpolation expression.\n     *\n     * @param {string} expression The code of the expression. E.g. `\"${42}\"`\n     * @returns {Token}\n     */function tokenizeInterpolationExpression(expression){var tempGrammar={};tempGrammar['interpolation-punctuation']=interpolationPunctuationObject;/** @type {Array} */var tokens=Prism.tokenize(expression,tempGrammar);if(tokens.length===3){/**\n         * The token array will look like this\n         * [\n         *     [\"interpolation-punctuation\", \"${\"]\n         *     \"...\" // JavaScript expression of the interpolation\n         *     [\"interpolation-punctuation\", \"}\"]\n         * ]\n         */var args=[1,1];args.push.apply(args,tokenizeWithHooks(tokens[1],Prism.languages.javascript,'javascript'));tokens.splice.apply(tokens,args);}return new Prism.Token('interpolation',tokens,interpolationObject.alias,expression);}/**\n     * Tokenizes the given code with support for JavaScript interpolation expressions mixed in.\n     *\n     * This function has 3 phases:\n     *\n     * 1. Replace all JavaScript interpolation expression with a placeholder.\n     *    The placeholder will have the syntax of a identify of the target language.\n     * 2. Tokenize the code with placeholders.\n     * 3. Tokenize the interpolation expressions and re-insert them into the tokenize code.\n     *    The insertion only works if a placeholder hasn't been \"ripped apart\" meaning that the placeholder has been\n     *    tokenized as two tokens by the grammar of the embedded language.\n     *\n     * @param {string} code\n     * @param {object} grammar\n     * @param {string} language\n     * @returns {Token}\n     */function tokenizeEmbedded(code,grammar,language){// 1. First filter out all interpolations\n// because they might be escaped, we need a lookbehind, so we use Prism\n/** @type {(Token|string)[]} */var _tokens=Prism.tokenize(code,{interpolation:{pattern:RegExp(interpolationPattern),lookbehind:true}});// replace all interpolations with a placeholder which is not in the code already\nvar placeholderCounter=0;/** @type {Object<string, string>} */var placeholderMap={};var embeddedCode=_tokens.map(function(token){if(typeof token==='string'){return token;}else{var interpolationExpression=token.content;var placeholder;while(code.indexOf(placeholder=getPlaceholder(placeholderCounter++,language))!==-1){}placeholderMap[placeholder]=interpolationExpression;return placeholder;}}).join('');// 2. Tokenize the embedded code\nvar embeddedTokens=tokenizeWithHooks(embeddedCode,grammar,language);// 3. Re-insert the interpolation\nvar placeholders=Object.keys(placeholderMap);placeholderCounter=0;/**\n       *\n       * @param {(Token|string)[]} tokens\n       * @returns {void}\n       */function walkTokens(tokens){for(var i=0;i<tokens.length;i++){if(placeholderCounter>=placeholders.length){return;}var token=tokens[i];if(typeof token==='string'||typeof token.content==='string'){var placeholder=placeholders[placeholderCounter];var s=typeof token==='string'?token:/** @type {string} */token.content;var index=s.indexOf(placeholder);if(index!==-1){++placeholderCounter;var before=s.substring(0,index);var middle=tokenizeInterpolationExpression(placeholderMap[placeholder]);var after=s.substring(index+placeholder.length);var replacement=[];if(before){replacement.push(before);}replacement.push(middle);if(after){var afterTokens=[after];walkTokens(afterTokens);replacement.push.apply(replacement,afterTokens);}if(typeof token==='string'){tokens.splice.apply(tokens,[i,1].concat(replacement));i+=replacement.length-1;}else{token.content=replacement;}}}else{var content=token.content;if(Array.isArray(content)){walkTokens(content);}else{walkTokens([content]);}}}}walkTokens(embeddedTokens);return new Prism.Token(language,embeddedTokens,'language-'+language,code);}/**\n     * The languages for which JS templating will handle tagged template literals.\n     *\n     * JS templating isn't active for only JavaScript but also related languages like TypeScript, JSX, and TSX.\n     */var supportedLanguages={javascript:true,js:true,typescript:true,ts:true,jsx:true,tsx:true};Prism.hooks.add('after-tokenize',function(env){if(!(env.language in supportedLanguages)){return;}/**\n       * Finds and tokenizes all template strings with an embedded languages.\n       *\n       * @param {(Token | string)[]} tokens\n       * @returns {void}\n       */function findTemplateStrings(tokens){for(var i=0,l=tokens.length;i<l;i++){var token=tokens[i];if(typeof token==='string'){continue;}var content=token.content;if(!Array.isArray(content)){if(typeof content!=='string'){findTemplateStrings([content]);}continue;}if(token.type==='template-string'){/**\n             * A JavaScript template-string token will look like this:\n             *\n             * [\"template-string\", [\n             *     [\"template-punctuation\", \"`\"],\n             *     (\n             *         An array of \"string\" and \"interpolation\" tokens. This is the simple string case.\n             *         or\n             *         [\"embedded-code\", \"...\"] This is the token containing the embedded code.\n             *                                  It also has an alias which is the language of the embedded code.\n             *     ),\n             *     [\"template-punctuation\", \"`\"]\n             * ]]\n             */var embedded=content[1];if(content.length===3&&typeof embedded!=='string'&&embedded.type==='embedded-code'){// get string content\nvar code=stringContent(embedded);var alias=embedded.alias;var language=Array.isArray(alias)?alias[0]:alias;var grammar=Prism.languages[language];if(!grammar){// the embedded language isn't registered.\ncontinue;}content[1]=tokenizeEmbedded(code,grammar,language);}}else{findTemplateStrings(content);}}}findTemplateStrings(env.tokens);});/**\n     * Returns the string content of a token or token stream.\n     *\n     * @param {string | Token | (string | Token)[]} value\n     * @returns {string}\n     */function stringContent(value){if(typeof value==='string'){return value;}else if(Array.isArray(value)){return value.map(stringContent).join('');}else{return stringContent(value.content);}}})(Prism);}","map":{"version":3,"names":["module","exports","jsTemplates","displayName","aliases","Prism","templateString","languages","javascript","templateLiteralPattern","pattern","source","interpolationObject","inside","interpolationPunctuationObject","interpolationPattern","createTemplate","language","tag","undefined","RegExp","lookbehind","greedy","alias","filter","Boolean","getPlaceholder","counter","toUpperCase","tokenizeWithHooks","code","grammar","env","hooks","run","tokens","tokenize","tokenizeInterpolationExpression","expression","tempGrammar","length","args","push","apply","splice","Token","tokenizeEmbedded","_tokens","interpolation","placeholderCounter","placeholderMap","embeddedCode","map","token","interpolationExpression","content","placeholder","indexOf","join","embeddedTokens","placeholders","Object","keys","walkTokens","i","s","index","before","substring","middle","after","replacement","afterTokens","concat","Array","isArray","supportedLanguages","js","typescript","ts","jsx","tsx","add","findTemplateStrings","l","type","embedded","stringContent","value"],"sources":["/home/andrea/progetti/andrea-portfolio/frontend/node_modules/refractor/lang/js-templates.js"],"sourcesContent":["'use strict'\n\nmodule.exports = jsTemplates\njsTemplates.displayName = 'jsTemplates'\njsTemplates.aliases = []\nfunction jsTemplates(Prism) {\n  ;(function(Prism) {\n    var templateString = Prism.languages.javascript['template-string'] // see the pattern in prism-javascript.js\n    var templateLiteralPattern = templateString.pattern.source\n    var interpolationObject = templateString.inside['interpolation']\n    var interpolationPunctuationObject =\n      interpolationObject.inside['interpolation-punctuation']\n    var interpolationPattern = interpolationObject.pattern.source\n    /**\n     * Creates a new pattern to match a template string with a special tag.\n     *\n     * This will return `undefined` if there is no grammar with the given language id.\n     *\n     * @param {string} language The language id of the embedded language. E.g. `markdown`.\n     * @param {string} tag The regex pattern to match the tag.\n     * @returns {object | undefined}\n     * @example\n     * createTemplate('css', /\\bcss/.source);\n     */\n    function createTemplate(language, tag) {\n      if (!Prism.languages[language]) {\n        return undefined\n      }\n      return {\n        pattern: RegExp('((?:' + tag + ')\\\\s*)' + templateLiteralPattern),\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          'template-punctuation': {\n            pattern: /^`|`$/,\n            alias: 'string'\n          },\n          'embedded-code': {\n            pattern: /[\\s\\S]+/,\n            alias: language\n          }\n        }\n      }\n    }\n    Prism.languages.javascript['template-string'] = [\n      // styled-jsx:\n      //   css`a { color: #25F; }`\n      // styled-components:\n      //   styled.h1`color: red;`\n      createTemplate(\n        'css',\n        /\\b(?:styled(?:\\([^)]*\\))?(?:\\s*\\.\\s*\\w+(?:\\([^)]*\\))*)*|css(?:\\s*\\.\\s*(?:global|resolve))?|createGlobalStyle|keyframes)/\n          .source\n      ), // html`<p></p>`\n      // div.innerHTML = `<p></p>`\n      createTemplate('html', /\\bhtml|\\.\\s*(?:inner|outer)HTML\\s*\\+?=/.source), // svg`<path fill=\"#fff\" d=\"M55.37 ...\"/>`\n      createTemplate('svg', /\\bsvg/.source), // md`# h1`, markdown`## h2`\n      createTemplate('markdown', /\\b(?:md|markdown)/.source), // gql`...`, graphql`...`, graphql.experimental`...`\n      createTemplate(\n        'graphql',\n        /\\b(?:gql|graphql(?:\\s*\\.\\s*experimental)?)/.source\n      ), // vanilla template string\n      templateString\n    ].filter(Boolean)\n    /**\n     * Returns a specific placeholder literal for the given language.\n     *\n     * @param {number} counter\n     * @param {string} language\n     * @returns {string}\n     */\n    function getPlaceholder(counter, language) {\n      return '___' + language.toUpperCase() + '_' + counter + '___'\n    }\n    /**\n     * Returns the tokens of `Prism.tokenize` but also runs the `before-tokenize` and `after-tokenize` hooks.\n     *\n     * @param {string} code\n     * @param {any} grammar\n     * @param {string} language\n     * @returns {(string|Token)[]}\n     */\n    function tokenizeWithHooks(code, grammar, language) {\n      var env = {\n        code: code,\n        grammar: grammar,\n        language: language\n      }\n      Prism.hooks.run('before-tokenize', env)\n      env.tokens = Prism.tokenize(env.code, env.grammar)\n      Prism.hooks.run('after-tokenize', env)\n      return env.tokens\n    }\n    /**\n     * Returns the token of the given JavaScript interpolation expression.\n     *\n     * @param {string} expression The code of the expression. E.g. `\"${42}\"`\n     * @returns {Token}\n     */\n    function tokenizeInterpolationExpression(expression) {\n      var tempGrammar = {}\n      tempGrammar['interpolation-punctuation'] = interpolationPunctuationObject\n      /** @type {Array} */\n      var tokens = Prism.tokenize(expression, tempGrammar)\n      if (tokens.length === 3) {\n        /**\n         * The token array will look like this\n         * [\n         *     [\"interpolation-punctuation\", \"${\"]\n         *     \"...\" // JavaScript expression of the interpolation\n         *     [\"interpolation-punctuation\", \"}\"]\n         * ]\n         */\n        var args = [1, 1]\n        args.push.apply(\n          args,\n          tokenizeWithHooks(tokens[1], Prism.languages.javascript, 'javascript')\n        )\n        tokens.splice.apply(tokens, args)\n      }\n      return new Prism.Token(\n        'interpolation',\n        tokens,\n        interpolationObject.alias,\n        expression\n      )\n    }\n    /**\n     * Tokenizes the given code with support for JavaScript interpolation expressions mixed in.\n     *\n     * This function has 3 phases:\n     *\n     * 1. Replace all JavaScript interpolation expression with a placeholder.\n     *    The placeholder will have the syntax of a identify of the target language.\n     * 2. Tokenize the code with placeholders.\n     * 3. Tokenize the interpolation expressions and re-insert them into the tokenize code.\n     *    The insertion only works if a placeholder hasn't been \"ripped apart\" meaning that the placeholder has been\n     *    tokenized as two tokens by the grammar of the embedded language.\n     *\n     * @param {string} code\n     * @param {object} grammar\n     * @param {string} language\n     * @returns {Token}\n     */\n    function tokenizeEmbedded(code, grammar, language) {\n      // 1. First filter out all interpolations\n      // because they might be escaped, we need a lookbehind, so we use Prism\n      /** @type {(Token|string)[]} */\n      var _tokens = Prism.tokenize(code, {\n        interpolation: {\n          pattern: RegExp(interpolationPattern),\n          lookbehind: true\n        }\n      }) // replace all interpolations with a placeholder which is not in the code already\n      var placeholderCounter = 0\n      /** @type {Object<string, string>} */\n      var placeholderMap = {}\n      var embeddedCode = _tokens\n        .map(function(token) {\n          if (typeof token === 'string') {\n            return token\n          } else {\n            var interpolationExpression = token.content\n            var placeholder\n            while (\n              code.indexOf(\n                (placeholder = getPlaceholder(placeholderCounter++, language))\n              ) !== -1\n            ) {}\n            placeholderMap[placeholder] = interpolationExpression\n            return placeholder\n          }\n        })\n        .join('') // 2. Tokenize the embedded code\n      var embeddedTokens = tokenizeWithHooks(embeddedCode, grammar, language) // 3. Re-insert the interpolation\n      var placeholders = Object.keys(placeholderMap)\n      placeholderCounter = 0\n      /**\n       *\n       * @param {(Token|string)[]} tokens\n       * @returns {void}\n       */\n      function walkTokens(tokens) {\n        for (var i = 0; i < tokens.length; i++) {\n          if (placeholderCounter >= placeholders.length) {\n            return\n          }\n          var token = tokens[i]\n          if (typeof token === 'string' || typeof token.content === 'string') {\n            var placeholder = placeholders[placeholderCounter]\n            var s =\n              typeof token === 'string'\n                ? token\n                : /** @type {string} */\n                  token.content\n            var index = s.indexOf(placeholder)\n            if (index !== -1) {\n              ++placeholderCounter\n              var before = s.substring(0, index)\n              var middle = tokenizeInterpolationExpression(\n                placeholderMap[placeholder]\n              )\n              var after = s.substring(index + placeholder.length)\n              var replacement = []\n              if (before) {\n                replacement.push(before)\n              }\n              replacement.push(middle)\n              if (after) {\n                var afterTokens = [after]\n                walkTokens(afterTokens)\n                replacement.push.apply(replacement, afterTokens)\n              }\n              if (typeof token === 'string') {\n                tokens.splice.apply(tokens, [i, 1].concat(replacement))\n                i += replacement.length - 1\n              } else {\n                token.content = replacement\n              }\n            }\n          } else {\n            var content = token.content\n            if (Array.isArray(content)) {\n              walkTokens(content)\n            } else {\n              walkTokens([content])\n            }\n          }\n        }\n      }\n      walkTokens(embeddedTokens)\n      return new Prism.Token(\n        language,\n        embeddedTokens,\n        'language-' + language,\n        code\n      )\n    }\n    /**\n     * The languages for which JS templating will handle tagged template literals.\n     *\n     * JS templating isn't active for only JavaScript but also related languages like TypeScript, JSX, and TSX.\n     */\n    var supportedLanguages = {\n      javascript: true,\n      js: true,\n      typescript: true,\n      ts: true,\n      jsx: true,\n      tsx: true\n    }\n    Prism.hooks.add('after-tokenize', function(env) {\n      if (!(env.language in supportedLanguages)) {\n        return\n      }\n      /**\n       * Finds and tokenizes all template strings with an embedded languages.\n       *\n       * @param {(Token | string)[]} tokens\n       * @returns {void}\n       */\n      function findTemplateStrings(tokens) {\n        for (var i = 0, l = tokens.length; i < l; i++) {\n          var token = tokens[i]\n          if (typeof token === 'string') {\n            continue\n          }\n          var content = token.content\n          if (!Array.isArray(content)) {\n            if (typeof content !== 'string') {\n              findTemplateStrings([content])\n            }\n            continue\n          }\n          if (token.type === 'template-string') {\n            /**\n             * A JavaScript template-string token will look like this:\n             *\n             * [\"template-string\", [\n             *     [\"template-punctuation\", \"`\"],\n             *     (\n             *         An array of \"string\" and \"interpolation\" tokens. This is the simple string case.\n             *         or\n             *         [\"embedded-code\", \"...\"] This is the token containing the embedded code.\n             *                                  It also has an alias which is the language of the embedded code.\n             *     ),\n             *     [\"template-punctuation\", \"`\"]\n             * ]]\n             */\n            var embedded = content[1]\n            if (\n              content.length === 3 &&\n              typeof embedded !== 'string' &&\n              embedded.type === 'embedded-code'\n            ) {\n              // get string content\n              var code = stringContent(embedded)\n              var alias = embedded.alias\n              var language = Array.isArray(alias) ? alias[0] : alias\n              var grammar = Prism.languages[language]\n              if (!grammar) {\n                // the embedded language isn't registered.\n                continue\n              }\n              content[1] = tokenizeEmbedded(code, grammar, language)\n            }\n          } else {\n            findTemplateStrings(content)\n          }\n        }\n      }\n      findTemplateStrings(env.tokens)\n    })\n    /**\n     * Returns the string content of a token or token stream.\n     *\n     * @param {string | Token | (string | Token)[]} value\n     * @returns {string}\n     */\n    function stringContent(value) {\n      if (typeof value === 'string') {\n        return value\n      } else if (Array.isArray(value)) {\n        return value.map(stringContent).join('')\n      } else {\n        return stringContent(value.content)\n      }\n    }\n  })(Prism)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}